# Author: Philippe Katz <philippe.katz@gmail.com>,
#         Sylvain Takerkart <Sylvain.Takerkart@incm.cnrs-mrs.fr>
# License: BSD Style.

try:
    from neuroProcesses import *
except:
    print 'Impossible to import neurProcesses'
    
try:
    import numpy as np
except:
    print 'Impossible to import numpy'
    
try:
    import manip_char
except ImportError:
    print 'Impossible to import manip_char'

# Header
userLevel=3 # Never visible

def print_fonc(string,context=None):
    """Print function for BrainVISA

    Print function for BrainVISA. Desactivated when context is None (for a use in bash mode)

    Parameters
    ----------
    string : str
        The string to print
    context : brainvisa context, optional
        Can be None for a use in bash mode or the BrainVISA context for a use in BrainVISA graphical mode
    """
    if context is None: # If no context, for a use in BrainVISA shell
        return
    else:
        context.write(_t_(string)) # If used in BrainVISA graphical mode

def warning_fonc(string,context=None):
    """Warning function for BrainVISA

    Warning function for BrainVISA.
    Print :
    * a string in bash when context is None (for a use in bash mode),
    * a warning message in BrainVISA user interface when context is BrainVISA context

    Parameters
    ----------
    string : str
        The string to print
    context : brainvisa context, optional
        Can be None for a use in bash mode or the BrainVISA context for a use in BrainVISA graphical mode
    """
    if context is None: # If no context, for a use in BrainVISA shell
        print string
    else:
        context.warning(_t_(string)) # If used in BrainVISA graphical mode

def error_fonc(string,context=None):
    """Error function for BrainVISA

    Error function for BrainVISA.
    Print :
    * a string in bash when context is None (for a use in bash mode)
    * a error message in BrainVISA user interface when context is BrainVISA context

    Parameters
    ----------
    string : str
        The string to print
    context : brainvisa context, optional
        Can be None for a use in bash mode or the BrainVISA context for a use in BrainVISA graphical mode
    """
    if context is None: # If no context, for a use in BrainVISA shell
        print string
        
    else:
        context.error(_t_(string)) # If used in BrainVISA graphical mode

def interruption( context ):
    """Interruption function for BrainVISA

    Interruption function of a script for BrainVISA. Stops the current process.

    Parameters
    ----------
    context : brainvisa context
        Can be None for a use in bash mode or the BrainVISA context for a use in BrainVISA graphical mode
    """
    if context is None: # If no context, for a use in BrainVISA shell
        return
    else:
        context.checkInterruption( ) # If used in BrainVISA graphical mode

try:
    import oitrial #Import of trial-level class for optical imaging
except:
    import oidata.oitrial as oitrial #Import of session-level class for optical imaging
try:
    import oisession #Import of session-level class for optical imaging
except:
    import oidata.oisession as oisession #Import of session-level class for optical imaging

def import_external_data_process( input, output=None, date=None, period=None, database=None,protocol=None, subject=None, format='.nii', mode=False, temporal_binning=1, spatial_binning=1, context=None ,script=False):
    """Importation of a data file, containing the raw image

    Importation of a data file, containing the raw image. can be a RSD or a BLK file
    Image saved as NIFTI-1 image or gz compressed NIFTI-1 image.

    Parameters
    ----------
    input : str
        The path of the external file, containing the raw image
    output : str, optional
        Output's name (DEPRECIATED)
    date : int, optional
        The date
    period : float, optional
        The acquisition period
    database : str, optional
        Database's path
    protocol : str, optional
        Protocol's name
    subject : str, optional
        Subject's name
    format : {'.nii','.nii.gz'}, optional
        Saving format of images. It can be NIFTI-1 Image ('.nii') or gzip compressed NIFTI-1 Image ('.nii.gz')
    mode : bool, optional
        The database mode
    temporal_binning : int, optional
        Number of consecutive temporal samples to be averaged into the imported file
    spatial_binning : int, optional
        Size (in pixels) of square window to be averaged into one pixel of the imported file
    context : brainvisa context, optional
        Can be None for a use in bash mode or the BrainVISA context for a use in BrainVISA graphical mode

    Returns
    -------
    this_trial_attributes : dict
        A dictionary containing data attributes :
        'session'
            (Session directory. Given by the prefix "session_" and the session date),
        'exp'
            (Experience directory),
        'trial'
            (Trial directory),
        'filename'
            (Image's filename),
        'path'
            (Image's path)
    """
    print_fonc('Initialization',context)
    interruption( context )

    import os

    # analysis of the content of the input filename, according to file format
    input_filename=os.path.splitext(os.path.basename(input))[0] # Filename recuperation
    file_extension = input[-3:].upper() # File extension recuperation
    if file_extension == 'BLK': # If BLK data file
        session = input_filename[8:10] + input_filename[6:8] + input_filename[4:6] # Session recuperation
        exp = input_filename[18:20] # Experience recuperation
        trial = '0' + input_filename[21:24] # Trial recuperation
        condition = '0' + input_filename[2:4] # Condition recuperation
        period = period * temporal_binning # Temporal sampling period of the output file
    elif file_extension == 'RSD': # If RSD data file
        session = str(date)[0:2] + input_filename[6:8] + input_filename[8:10] # Session recuperation
        exp = '01' # Experience recuperation
        if len(input_filename) == 18: # Trial with four digits!! trial number >= 1000
            trial = input_filename[11:15] # Trial number
        elif len(input_filename) == 17: # Trial with four digits!! trial number < 1000
            trial = '0' + input_filename[11:14] # Trial number
        condition = '0' + input_filename[3:5] # Condition number
        period = period * temporal_binning # Temporal sampling period of the output file

    # everything else is common to all formats
    this_trial=oitrial.OiTrial( database = database, protocol = protocol, subject = subject, session = session, exp = exp, trial = trial, format = format, database_mode = mode, condition = condition ) # OiTrial instance creation
    this_trial.set_nifti_header( period=period ) # Set values to NIFTI-1 header
    print_fonc("Reading data",context)
    print_fonc(temporal_binning,context)
    interruption( context )
    this_trial.load_external_file( input, temporal_binning , spatial_binning) #  Loads a data file, containing the raw image
    output_filename = 's' + session + '_e' + exp + '_t' + trial + '_c' + condition + this_trial.format # Output filename creation
        
    output_fullpath = os.path.join( this_trial.database, this_trial.protocol, this_trial.subject, 'session_' + session, 'oitrials_analysis', 'exp' + exp, 'trial' + trial, 'raw', output_filename ) # Output path creation

    print_fonc("Writing on disk",context)
    interruption( context )
    (db_fit,path)=this_trial.save_raw( output_fullpath ) # Saves raw image as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI-1 Image)

    if db_fit == -1:
        warning_fonc("Output path doesn't correspond to any database",context) # Writes a warning message if the path does not correspond to the path created by the database mode

    if context == None and mode == True and script==False:
        this_trial.update_database( output_fullpath ) # Updating database

    if (input.endswith('.rsd') or input.endswith('.RSD')) and (date is None):
        date = datetime.now().year # date recuperation
    
    this_trial_attributes = {"session":this_trial.session,"exp":this_trial.exp,"trial":this_trial.trial,"filename":this_trial.filename,"path":path,"condition":this_trial.condition} # Setting attributes
    return this_trial_attributes

def estimate_model_process(data, glm=None, betas=None, residuals=None, denoised=None, analysis=None, format='.nii', mode=False, corner0=None, corner1=None,mask=None, data_graph=None, context=None, script=False):
    """Estimation and denoising of input signal using the Linear Model.
       In addition, creation of a graph which show decomposition fo the signal 

    Saves as NIFTI-1 image or gz compressed NIFTI-1 image :
        * The denoised image
        * The betas
        * The residual noise

    Parameters
    ----------
    data : str
        The path of the external file, containing the raw NIFTI image
    glm : str, optional
        The path of the Linear Model
    betas : str, optional
        The path where to save betas
    residuals : str, optional
        The path where to save residual noise
    denoised : str, optional
        The path where to save the denoised image
    analysis : str, optional
        The name of the analysis directory
    format : {'.nii','.nii.gz'}, optional
        Saving format of images. It can be NIFTI-1 Image ('.nii') or gzip compressed NIFTI-1 Image ('.nii.gz')
    mode : bool, optional
        The database mode
    corner0 : int tuple, optional
        Top left-hand corner
    corner1 : int tuple, optional
        Bottom right-hand corner
    path_mask : str, optional
        Path of binary mask
    data_graph : str
        Path of the data graph created
    context : brainvisa context, optional
        Can be None for a use in bash mode or the BrainVISA context for a use in BrainVISA graphical mode

    Returns
    -------
    output_paths : dict
        A dictionary containing datas paths attributes :
        'path_betas'
            (Betas directory),
        'path_residuals'
            (Residual noise directory),
        'path_denoised'
            (Denoised image directory)
    """
    path_raw=data
    path_mask=mask
    interruption( context )
    print_fonc('Initialization',context)
    this_trial=oitrial.OiTrial( analysis=analysis, format=format, database_mode=mode ) # OiTrial instance creation
    this_session=oisession.OiSession(format=format) # OiSession instance initialization
       
    db_fit=this_trial.set_raw_path( data ) # Set the raw path

    if db_fit == -1:
        warning_fonc("Output path doesn't correspond to any database",context) # Writes a warning message if the path does not correspond to the path created by the database mode

    this_trial.set_glm(glm) # Loads Model's path

    interruption( context )

    print_fonc("Reading data",context)
    this_trial.copy_rawdata_and_model_definition() # Copies the model definition from the session-level analysis directory to the trial-level directory
    data=this_trial.load_rawdata_and_model_definition() # Loads the raw image and the model definition

    interruption( context )
    print_fonc("Estimation",context)
    this_trial.estimate_glm() # Estimation of input signal using the Linear Model
    
    interruption( context )
    print_fonc("Denoising",context)
    this_trial.denoise_data() # Input signal denoising
    this_session.load_averaged_img(path=path_raw) # Loads an existing session averaged image
    
    if path_mask == None:                                  
        this_session.create_rectangle_mask(corner0, corner1) # Creates a rectangle mask which defines the region to average
    else:
        print_fonc("Loading mask",context)
        db_fit=this_session.load_mask(path=path_mask) # Loads an existing mask
        if db_fit[0]==-1: # Writes an error message and stops the current process if the path does not exist
            error_fonc("Path does not exist",context)
    # Mask parameters recovery        
    this_trial.mask=this_session.mask
    this_trial.mask_name=this_session.mask_name
        
    interruption( context )
    print_fonc("Create signal decomposition graph",context)
    this_trial.plot_decomposition()  
      
    interruption( context )
    print_fonc("Writing on disk : Betas",context)
    (db_fit,path_betas)=this_trial.save_betas(betas) # Saves betas as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI-1 Image)
    
    if db_fit == -1:
        warning_fonc("Output path doesn't correspond to any database",context)

    interruption( context )
    print_fonc("Writing on disk : Residuals",context)
    (db_fit,path_residuals)=this_trial.save_residuals(residuals) # Saves residual noise as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI

    if db_fit == -1:
        warning_fonc("Output path doesn't correspond to any database",context) # Writes a warning message if the path does not correspond to the path created by the database mode

    interruption( context )
    print_fonc("Writing on disk : Denoised data",context)
    (db_fit,path_denoised)=this_trial.save_denoised(denoised) # Saves denoised image as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI
    
    if db_fit == -1:
        warning_fonc("Output path doesn't correspond to any database",context) # Writes a warning message if the path does not correspond to the path created by the database mode

    interruption( context )
    print_fonc("Writing on disk : graph of signal decomposition")
    this_trial.save_data_graph(data_graph)
    print_fonc('Data graph of signal saved => Viewer available') 
    
    if context == None and mode == True and script==False:
        this_trial.update_database() # Updating database

    output_paths = {"path_betas":path_betas,"path_residuals":path_residuals,"path_denoised":path_denoised} # Setting attributes
    return output_paths

def estimate_model_with_physio_params_process(physio_params_file, data, glm=None, betas=None, residuals=None, denoised=None, analysis=None, format='.nii', mode=False, corner0=None, corner1=None,mask=None, data_graph=None, context=None, script=False): 
    """Estimation and denoising of input signal using the Linear Model.
       In addition, creation of a graph which show decomposition fo the signal 

    Saves as NIFTI-1 image or gz compressed NIFTI-1 image :
        * The denoised image
        * The betas
        * The residual noise

    Parameters
    ----------
    data : str
        The path of the external file, containing the raw NIFTI image
    glm : str, optional
        The path of the Linear Model
    physio_params_file:str
        The path of the file containing physiological parameters determined externally
    betas : str, optional
        The path where to save betas
    residuals : str, optional
        The path where to save residual noise
    denoised : str, optional
        The path where to save the denoised image
    analysis : str, optional
        The name of the analysis directory
    format : {'.nii','.nii.gz'}, optional
        Saving format of images. It can be NIFTI-1 Image ('.nii') or gzip compressed NIFTI-1 Image ('.nii.gz')
    mode : bool, optional
        The database mode
    corner0 : int tuple, optional
        Top left-hand corner
    corner1 : int tuple, optional
        Bottom right-hand corner
    path_mask : str, optional
        Path of binary mask
    data_graph : str
        Path of the data graph created
    glm_physio:str
        Path of the Linear Model for a trial with physiological parameters entered
    context : brainvisa context, optional
        Can be None for a use in bash mode or the BrainVISA context for a use in BrainVISA graphical mode

    Returns
    -------
    output_paths : dict
        A dictionary containing datas paths attributes :
        'path_betas'
            (Betas directory),
        'path_residuals'
            (Residual noise directory),
        'path_denoised'
            (Denoised image directory)
    """
    


    #first stage: read the GLM textfile
    path_raw=data
    #print ('path_raw = %s' % path_raw)
    path_mask=mask
    interruption( context )
    print_fonc('Initialization',context)
    this_trial=oitrial.OiTrial( analysis=analysis, format=format, database_mode=mode ) # OiTrial instance creation
    this_session=oisession.OiSession(format=format) # OiSession instance initialization
    
    db_fit=this_trial.set_raw_path( data ) # Set the raw path

    if db_fit == -1:
        warning_fonc("Output path doesn't correspond to any database",context) # Writes a warning message if the path does not correspond to the path created by the database mode

    this_trial.set_glm(glm) # Loads Model's path

    interruption( context )

    print_fonc("Reading data",context)
    this_trial.copy_rawdata_and_model_definition() # Copies the model definition from the session-level analysis directory to the trial-level directory
    data=this_trial.load_rawdata_and_model_definition() # Loads the raw image and the model definition

    this_trial.X=np.loadtxt(this_trial.pathGLM) # Loads model definition matrix from file

    """
    this_trial.__pathRAW=os.path.join( this_trial.database, this_trial.protocol, this_trial.subject, this_trial.session,'oitrials_analysis', this_trial.exp, this_trial.trial,'raw', this_trial.filename +  this_trial.format ) # __pathRAW creation
  """
    

    #print('****************')
    #print(this_trial.pathGLM)
    #print('****************')
    #print( this_trial.X)
    #print(len(this_trial.X))
    
    this_trial.physio=np.loadtxt(physio_params_file, dtype=str )
    #print('---------')
    #print(this_trial.physio)
    
    interruption( context )
    


    #find if trial belong to the physio_params_file
    trialnames,hbf,hbdeph,rf,rdeph=np.loadtxt(physio_params_file, dtype=str, unpack=True )
    # in case there is only one file in the Conditions File
    if type(trialnames) != np.ndarray:
        trialnames = np.array([trialnames])
        hbf = np.array([hbf])
        hbdeph = np.array([hbdeph])
        rf = np.array([rf])
        rdeph = np.array([rdeph])
    #print(trialnames)
    #print(this_trial.filename)
    #print('*********')
    #print( hbf)
    #print('*********')
    #print( hbdeph)
    #print('*********')
    #print(  rf)
    #print('*********')
    #print( rdeph)

    for current_ind, current_trial in enumerate(trialnames):
        if current_trial.find(this_trial.filename) > -1:
              current_freqcard = float(hbf[current_ind])
              current_freqresp = float(rf[current_ind])
              current_dephcard = float(hbdeph[current_ind])
              current_dephresp = float(rdeph[current_ind])
              good_ind = current_ind
              good_trial = current_trial

    #print good_trial, current_freqcard, good_ind

   
    f1=open(os.path.join(this_trial.database, this_trial.protocol, this_trial.subject, this_trial.session,'oisession_analysis',this_trial.analysis,'param.npz'))# Opening parameters file
    params=pickle.load(f1) # Recuperation of the sampling frequency
    #print params
    
    sampling_frequency=params[0]
    trialduration=params[1]
    alphas_max=params[7]
    
    #print sampling_frequency 
    #print trialduration
    #print alphas_max
    
    total_model_length = np.array(eval( manip_char.standardize(alphas_max))[0:6]).sum()
    if total_model_length < trialduration:
        total_model_length = trialduration
    
    time_vector=np.arange(0,round(total_model_length*sampling_frequency)) / sampling_frequency



    #generate cos and sin based on the physio parameters 

    
    Xphysio=this_trial.gen_cos_sin(time_vector,params,current_freqcard, current_freqresp, current_dephcard, current_dephresp)
  
    # Restrict the model definition to the actual length of a trial
    restricted_time_vector=np.arange(0,round(trialduration*sampling_frequency)) / sampling_frequency
    nbr_samples_per_trial = len(restricted_time_vector)
    Xphysio =Xphysio[0:nbr_samples_per_trial,:]

    this_trial.nbr_of_physio_regressors=Xphysio.shape[1] 
    #print('number of regressors extracted from physiological parameters file')
    #print( this_trial.nbr_of_physio_regressors)

    this_trial.X = np.hstack((this_trial.X, Xphysio))
    
    # save new glm.txt file with added physiological regressors
    #pathGLM_physio=os.path.join(this_trial.database,this_trial.protocol,this_trial.subject,this_trial.session,'oisession_analysis',this_trial.analysis,'glm_physio.txt') # pathGLM_physio creation
    pathGLM_physio=os.path.join( this_trial.database, this_trial.protocol, this_trial.subject, this_trial.session,'oitrials_analysis', this_trial.exp, this_trial.trial,this_trial.analysis,'glm_physio.txt')
    #print(pathGLM_physio)
    
    np.savetxt(pathGLM_physio,this_trial.X) # Save of model definition with physio regressors in a txt file
    
    
    f1.close() # Closing parameters file
    
    print_fonc("Estimation",context)
    this_trial.estimate_glm() # Estimation of input signal using the Linear Model
    
    
    interruption( context )
    print_fonc("Denoising",context)
    this_trial.denoise_data_with_physio_glm() # Input signal denoising
    this_session.load_averaged_img(path=path_raw) # Loads an existing session averaged image
    
    if path_mask == None:                                  
        this_session.create_rectangle_mask(corner0, corner1) # Creates a rectangle mask which defines the region to average
    else:
        print_fonc("Loading mask",context)
        db_fit=this_session.load_mask(path=path_mask) # Loads an existing mask
        if db_fit[0]==-1: # Writes an error message and stops the current process if the path does not exist
            error_fonc("Path does not exist",context)
    # Mask parameters recovery        
    this_trial.mask=this_session.mask
    this_trial.mask_name=this_session.mask_name
        
    interruption( context )
    print_fonc("Create signal decomposition graph",context)
    this_trial.plot_decomposition()  
      
    interruption( context )
    print_fonc("Writing on disk : Betas",context)
    (db_fit,path_betas)=this_trial.save_betas(betas) # Saves betas as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI-1 Image)
    
    if db_fit == -1:
        warning_fonc("Output path doesn't correspond to any database",context)

    interruption( context )
    print_fonc("Writing on disk : Residuals",context)
    (db_fit,path_residuals)=this_trial.save_residuals(residuals) # Saves residual noise as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI

    if db_fit == -1:
        warning_fonc("Output path doesn't correspond to any database",context) # Writes a warning message if the path does not correspond to the path created by the database mode

    interruption( context )
    print_fonc("Writing on disk : Denoised data",context)
    (db_fit,path_denoised)=this_trial.save_denoised(denoised) # Saves denoised image as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI
    
    if db_fit == -1:
        warning_fonc("Output path doesn't correspond to any database",context) # Writes a warning message if the path does not correspond to the path created by the database mode

    #print data_graph

    interruption( context )
    print_fonc("Writing on disk : graph of signal decomposition")
    this_trial.save_data_graph(data_graph)
    print_fonc('Data graph of signal saved => Viewer available') 
    
    if context == None and mode == True and script==False:
        this_trial.update_database() # Updating database

    output_paths = {"path_betas":path_betas,"path_residuals":path_residuals,"path_denoised":path_denoised} # Setting attributes
    return output_paths


def frame0_subtraction_process( window,path_data,path_f0=None,database=None,protocol=None,subject=None,session=None,exp=None,trial=None,analysis=None, format='.nii', mode=False,context=None ):
    """The frame0 subtraction process

    Parameters
    ----------
    window : list
        The datas of a time serie used to substract the global time serie (time1,time2)
    path_data : str
        The input image
    path_f0 : str, optional
        The path where to save the output image
    database : str, optional
        Database's path
    protocol : str, optional
        Protocol's name
    subject : str, optional
        Subject's name
    session : str, optional
        Session directory. Given by the prefix "session_" and the session date.
    exp : str, optional
        Experience directory
    trial : str, optional
        Trial directory
    analysis : str, optional
        The name of the analysis directory
    format : {'.nii','.nii.gz'}, optional
        Saving format of images. It can be NIFTI-1 Image ('.nii') or gzip compressed NIFTI-1 Image ('.nii.gz')
    mode : bool, optional
        The database mode
    context : brainvisa context, optional
        Can be None for a use in bash mode or the BrainVISA context for a use in BrainVISA graphical mode

    Returns
    -------
    path : str
        The path of the image after frame0 subtraction
    """
    interruption( context )
    print_fonc('Initialization',context)
    interruption( context )

    Frame0=oitrial.OiTrial( database=database,protocol=protocol,subject=subject,session=session,exp=exp,trial=trial,analysis=analysis, format=format, database_mode=mode ) # OiTrial instance initialization

    interruption( context )
    print_fonc("Reading data",context)

    Frame0.load_raw( path_data ) # Loads the raw image and modifies the path of analysis

    interruption( context )
    print_fonc("Denoising",context)
    Frame0.frame0_subtraction( Frame0.get_raw(),window ) # The frame0 subtraction

    interruption( context )
    print_fonc("Writing on disk",context)
    (db_fit,path)=Frame0.save_bksd( path_f0 ) # Saves image obtained by bksd method processing as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI-1 Image)

    if db_fit == -1:
        warning_fonc("Output path doesn't correspond to any database",context) # Writes a warning message if the path does not correspond to the path created by the database mode

    if context == None and mode == True:
        Frame0.update_database() # Updating database

    return path

def frame0_division_process( window,path_data,path_f0=None,database=None,protocol=None,subject=None,session=None,exp=None,trial=None,analysis=None, format='.nii', mode=False,context=None, script=False):
    """The frame0 division process

    Parameters
    ----------
    window : list
        The datas of a time serie used to divide the global time serie (time1,time2)
    path_data : str
        The input image
    path_f0 : str, optional
        The path where to save the output image
    database : str, optional
        Database's path
    protocol : str, optional
        Protocol's name
    subject : str, optional
        Subject's name
    session : str, optional
        Session directory. Given by the prefix "session_" and the session date.
    exp : str, optional
        Experience directory
    trial : str, optional
        Trial directory
    analysis : str, optional
        The name of the analysis directory
    format : {'.nii','.nii.gz'}, optional
        Saving format of images. It can be NIFTI-1 Image ('.nii') or gzip compressed NIFTI-1 Image ('.nii.gz')
    mode : bool, optional
        The database mode
    context : brainvisa context, optional
        Can be None for a use in bash mode or the BrainVISA context for a use in BrainVISA graphical mode

    Returns
    -------
    path : str
        The path of the image after frame0 division
    """
    interruption( context )
    print_fonc('Initialization',context)
    interruption( context )

    Frame0=oitrial.OiTrial( database=database,protocol=protocol,subject=subject,session=session,exp=exp,trial=trial,analysis=analysis, format=format, database_mode=mode ) # OiTrial instance initialization

    interruption( context )
    print_fonc("Reading data",context)

    Frame0.load_raw( path_data ) # Loads the raw image and modifies the path of analysis

    interruption( context )
    print_fonc("Denoising",context)
    Frame0.frame0_division( Frame0.get_raw(),window ) # The frame0 division

    interruption( context )
    print_fonc("Writing on disk",context)
    (db_fit,path)=Frame0.save_bksd( path_f0 ) # Saves image obtained by bksd method processing as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI-1 Image)

    if db_fit == -1:
        warning_fonc("Output path doesn't correspond to any database",context) # Writes a warning message if the path does not correspond to the path created by the database mode

    if context == None and mode == True and script == False:
        Frame0.update_database() # Updating database

    return path

def linear_detrend_process( window0,window1,path_data,path_f0=None,database=None,protocol=None,subject=None,session=None,exp=None,trial=None,analysis=None, format='.nii', mode=False,context=None, script=False):
    """The linear detrend process

    Parameters
    ----------
    window0 : list
        The datas at the begin of a time serie used to detrend the global time serie (time1,time2)
    window1 : list
        The datas at the end of a time serie used to detrend the global time serie (time1,time2)
    path_data : str
        The input image
    path_f0 : str, optional
        The path where to save the output image
    database : str, optional
        Database's path
    protocol : str, optional
        Protocol's name
    subject : str, optional
        Subject's name
    session : str, optional
        Session directory. Given by the prefix "session_" and the session date.
    exp : str, optional
        Experience directory
    trial : str, optional
        Trial directory
    analysis : str, optional
        The name of the analysis directory
    format : {'.nii','.nii.gz'}, optional
        Saving format of images. It can be NIFTI-1 Image ('.nii') or gzip compressed NIFTI-1 Image ('.nii.gz')
    mode : bool, optional
        The database mode
    context : brainvisa context, optional
        Can be None for a use in bash mode or the BrainVISA context for a use in BrainVISA graphical mode

    Returns
    -------
    path : str
        The path of the image after linear detrend
    """
    interruption( context )
    print_fonc('Initialization',context)
    interruption( context )

    Frame0=oitrial.OiTrial( database=database,protocol=protocol,subject=subject,session=session,exp=exp,trial=trial,analysis=analysis, format=format, database_mode=mode ) # OiTrial instance initialization

    interruption( context )
    print_fonc("Reading data",context)

    Frame0.load_raw( path_data ) # Loads the raw image and modifies the path of analysis

    interruption( context )
    print_fonc("Denoising",context)
    Frame0.linear_detrend( Frame0.get_raw(),window0,window1 ) # the linear detrending

    interruption( context )
    print_fonc("Writing on disk",context)
    (db_fit,path)=Frame0.save_bksd( path_f0 ) # Saves image obtained by bksd method processing as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI-1 Image)

    if db_fit == -1:
        warning_fonc("Output path doesn't correspond to any database",context) # Writes a warning message if the path does not correspond to the path created by the database mode

    if context == None and mode == True and script == False:
        Frame0.update_database() # Updating database

    return path

def blank_subtraction_process( path_data,path_average,path_bksd=None,database=None,protocol=None,subject=None,session=None,exp=None,trial=None,analysis=None, format='.nii', mode=False,context=None,script=False ):
    """The blank subtraction process

    Parameters
    ----------
    path_data : str
        The input image        
    path_average : str
        The averaged raw image
    path_bksd : str, optional
        The path where to save the output image
    database : str, optional
        Database's path
    protocol : str, optional
        Protocol's name
    subject : str, optional
        Subject's name
    session : str, optional
        Session directory. Given by the prefix "session_" and the session date.
    exp : str, optional
        Experience directory
    trial : str, optional
        Trial directory
    analysis : str, optional
        The name of the analysis directory
    format : {'.nii','.nii.gz'}, optional
        Saving format of images. It can be NIFTI-1 Image ('.nii') or gzip compressed NIFTI-1 Image ('.nii.gz')
    mode : bool, optional
        The database mode
    context : brainvisa context, optional
        Can be None for a use in bash mode or the BrainVISA context for a use in BrainVISA graphical mode

    Returns
    -------
    path : str
        The path of the image after blank subtraction
    """
    interruption( context )
    print_fonc('Initialization',context)
    interruption( context )

    Blank=oitrial.OiTrial( database=database,protocol=protocol,subject=subject,session=session,exp=exp,trial=trial,analysis=analysis, format=format, database_mode=mode ) # OiTrial instance initialization

    interruption( context )
    print_fonc("Reading data",context)

    Blank.load_bksd( path_data,path_average ) # Loads the raw image and modifies the path of analysis

    interruption( context )
    print_fonc("Denoising",context)
    Blank.blank_subtraction( Blank.get_raw() ) # The blank subtraction

    interruption( context )
    print_fonc("Writing on disk",context)
    (db_fit,path)=Blank.save_bksd( path_bksd ) # Saves image obtained by bksd method processing as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI-1 Image)

    if db_fit == -1:
        warning_fonc("Output path doesn't correspond to any database",context) # Writes a warning message if the path does not correspond to the path created by the database mode

    if context == None and mode == True and script == False:
        Blank.update_database() # Updating database

    return path

def blank_division_process( path_data,path_average,path_bksd=None,database=None,protocol=None,subject=None,session=None,exp=None,trial=None,analysis=None, format='.nii', mode=False,context=None ):
    """The blank division process

    Parameters
    ----------
    path_data : str
        The input image        
    path_average : str
        The averaged raw image
    path_bksd : str, optional
        The path where to save the output image
    database : str, optional
        Database's path
    protocol : str, optional
        Protocol's name
    subject : str, optional
        Subject's name
    session : str, optional
        Session directory. Given by the prefix "session_" and the session date.
    exp : str, optional
        Experience directory
    trial : str, optional
        Trial directory
    analysis : str, optional
        The name of the analysis directory
    format : {'.nii','.nii.gz'}, optional
        Saving format of images. It can be NIFTI-1 Image ('.nii') or gzip compressed NIFTI-1 Image ('.nii.gz')
    mode : bool, optional
        The database mode
    context : brainvisa context, optional
        Can be None for a use in bash mode or the BrainVISA context for a use in BrainVISA graphical mode

    Returns
    -------
    path : str
        The path of the image after blank division
    """
    interruption( context )
    print_fonc('Initialization',context)
    interruption( context )

    Blank=oitrial.OiTrial( database=database,protocol=protocol,subject=subject,session=session,exp=exp,trial=trial,analysis=analysis, format=format, database_mode=mode ) # OiTrial instance initialization

    interruption( context )
    print_fonc("Reading data",context)

    Blank.load_bksd( path_data,path_average ) # Loads a bksd image, obtained after processing the bksd method, and an averaged raw image

    interruption( context )
    print_fonc("Denoising",context)
    Blank.blank_division( Blank.get_raw() ) # The blank division

    interruption( context )
    print_fonc("Writing on disk",context)
    (db_fit,path)=Blank.save_bksd( path_bksd ) # Saves image obtained by bksd method processing as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI-1 Image)

    if db_fit == -1:
        warning_fonc("Output path doesn't correspond to any database",context) # Writes a warning message if the path does not correspond to the path created by the database mode

    if context == None and mode == True:
        Blank.update_database() # Updating database

    return path


