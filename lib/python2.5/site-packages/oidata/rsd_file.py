# Author: Philippe Katz <philippe.katz@gmail.com>,
#         Sylvain Takerkart <Sylvain.Takerkart@incm.cnrs-mrs.fr>
# License: BSD Style.

class RsdFile:
	"""This class contains some methods to load data from RSD file and write it into NIFTI format

	Attributes
	----------
	header : dict
	    The header of the input BLK File
	data : numpy array
	    The data of the input BLK File without transformation
	image : numpy array
	    The data after transformation, in a 4D image format
	p : str
	    len of string
	h : str
	    len of short
	H : str
	    len of unsigned short
	i : str
	    len of integer
	f : str
	    len of float
	l : str
	    len of long
	filename : str
	    The path of the input RSD file

	Methods
	-------
	__init__( ... )
	    Initializes attributes
	sizeofunity( ... )
	    Adaptation of data type size
	get_head( ... )
	    Reads each field of BLK file's header and save them into a dictionnary
	get_data( ... )
	    Reads the data contained in the BLK file
	get_4d_image( ... )
	    Reads the data contained in the BLK file
	"""

	def __init__(self,filename):
		"""Initializes attributes

		Default values for:
		* p : '1p'
		* h : '2h'
		* H : '2H'
		* i : '4i'
		* f : '4f'
		* l : '8l'

		Parameters
		----------
		filename : str
		    The path of the external file, containing the raw image
		"""
		# Adaptation of data type size
		self.p = self.sizeofunity(1,'p')
		self.h = self.sizeofunity(2,'h')
		self.H = self.sizeofunity(2,'H')
		self.i = self.sizeofunity(4,'i')
		self.f = self.sizeofunity(4,'f')
		self.l = self.sizeofunity(8,'l')
		self.filename=filename
		self.header={}
		self.data=None
		self.image=None

	def sizeofunity(self,size,string):
		"""Adaptation of data type size

		Every system don't has the same data type size. This function makes an adaptation of this size to let the script compatible on every system.

		Parameters
		----------
		size : int
		    The size of the wanted unity
		string : {'p','h','H','i','f','l'}
		    'p' : char[],
		    'h' : short,
		    'H' : unsigned short,
		    'i' : integer,
		    'f' : float,
		    'l' : long

		Returns
		-------
		size_of_unity : str
		    A concatenation of data type and the type size evaluted on every system
		"""
		import struct
		unit = str(size/struct.calcsize(string)) # The wanted size of data type divided by the data type size of the system

		size_of_unity = unit+string # Concatenation of unit and data type name
		return size_of_unity

	def get_head(self):
		"""Reads each field of RSD file's header and save them into a dictionnary

		Returns
		-------
		header : dict
		    The head of the BLK file, containings meta-datas
		"""
		from struct import unpack, calcsize

		fid = open(self.filename,'r')

		filesize = fid.read(8)
		self.header['filesize'] = unpack(self.l,filesize)[0]

		checksum_header = fid.read(2)
		self.header['checksum_header'] = unpack(self.h,checksum_header)[0]

		checksum_data= fid.read(2)
		self.header['checksum_data'] = unpack(self.h,checksum_data)[0]

		lenheader = fid.read(4)
		self.header['lenheader'] = unpack(self.i,lenheader)[0]

		versionid = fid.read(4)
		self.header['versionid'] = unpack(self.f,versionid)[0]

		filetype = fid.read(4)
		self.header['filetype'] = unpack(self.i,filetype)[0]
        		# RAWBLOCK_FILE          (11)
		        # DCBLOCK_FILE           (12)
	        	# SUM_FILE               (13)

		filesubtype = fid.read(4)
		self.header['filesubtype'] = unpack(self.i,filesubtype)[0]
		        # FROM_VDAQ              (11)
		        # FROM_ORA               (12)
		        # FROM_DYEDAQ            (13)

		datatype = fid.read(4)
		self.header['datatype'] = unpack(self.i,datatype)[0]
		        # DAT_UCHAR     (11)
		        # DAT_USHORT    (12)
		        # DAT_LONG      (13)
		        # DAT_FLOAT     (14)

		sizeof = fid.read(4)
		self.header['sizeof'] = unpack(self.i,sizeof)[0]
		        # e.g. sizeof(long), sizeof(float)

		framewidth = fid.read(4)
		self.header['framewidth'] = unpack(self.i,framewidth)[0]

		frameheidth = fid.read(4)
		self.header['frameheidth'] = unpack(self.i,frameheidth)[0]

		nframesperstim = fid.read(4)
		self.header['nframesperstim'] = unpack(self.i,nframesperstim)[0]

		nstimuli = fid.read(4)
		self.header['nstimuli'] = unpack(self.i,nstimuli)[0]

		initialxbinfactor = fid.read(4)
		self.header['initialxbinfactor'] = unpack(self.i,initialxbinfactor)[0]
        		# from data acquisition

		initialybinfactor = fid.read(4)
		self.header['initialybinfactor'] = unpack(self.i,initialybinfactor)[0]
        		# from data acquisition

		xbinfactor = fid.read(4)
		self.header['xbinfactor'] = unpack(self.i,xbinfactor)[0]
        		# this file

		ybinfactor = fid.read(4)
		self.header['ybinfactor'] = unpack(self.i,ybinfactor)[0]
        		# this file

		self.header['username'] = fid.read(32)

		recordingdate = fid.read(16)
		self.header['recordingdate'] = unpack(str(int(self.p[0:-1])*16)+self.p[-1],recordingdate)

		x1roi = fid.read(4)
		self.header['x1roi'] = unpack(self.i,x1roi)[0]

		y1roi = fid.read(4)
		self.header['y1roi'] = unpack(self.i,y1roi)[0]

		x2roi = fid.read(4)
		self.header['x2roi'] = unpack(self.i,x2roi)[0]

		y2roi = fid.read(4)
		self.header['y2roi'] = unpack(self.i,y2roi)[0]

		stimoffs = fid.read(4)
		self.header['stimoffs'] = unpack(self.i,stimoffs)[0]

		stimsize = fid.read(4)
		self.header['stimsize'] = unpack(self.i,stimsize)[0]

		frameoffs = fid.read(4)
		self.header['frameoffs'] = unpack(self.i,frameoffs)[0]

		framesize = fid.read(4)
		self.header['framesize'] = unpack(self.i,framesize)[0]

		refoffs = fid.read(4)
		self.header['refoffs'] = unpack(self.i,refoffs)[0]

		refsize = fid.read(4)
		self.header['refsize'] = unpack(self.i,refsize)[0]

		refwidth = fid.read(4)
		self.header['refwidth'] = unpack(self.i,refwidth)[0]

		refheight = fid.read(4)
		self.header['refheight'] = unpack(self.i,refheight)[0]

		whichblocks = fid.read(2*16)
		self.header['whichblocks'] = unpack(str(int(self.H[0:-1])*16)+self.H[-1],whichblocks)[0]

		whichframes = fid.read(2*16)
		self.header['whichframes'] = unpack(str(int(self.H[0:-1])*16)+self.H[-1],whichframes)[0]

		# DATA ANALYSIS
		loclip = fid.read(4)
		self.header['loclip'] = unpack(self.i,loclip)[0]

		hiclip = fid.read(4)
		self.header['hiclip'] = unpack(self.i,hiclip)[0]

		lopass = fid.read(4)
		self.header['lopass'] = unpack(self.i,lopass)[0]

		hipass = fid.read(4)
		self.header['hipass'] = unpack(self.i,hipass)[0]

		self.header['operationsperformed'] = fid.read(64)

		# ORA-SPECIFIC
		magnification = fid.read(4)
		self.header['magnification'] = unpack(self.f,magnification)[0]

		gain = fid.read(2)
		self.header['gain'] = unpack(self.H,gain)[0]

		wavelength = fid.read(2)
		self.header['wavelength'] = unpack(self.H,wavelength)[0]

		exposuretime = fid.read(4)
		self.header['exposuretime'] = unpack(self.i,exposuretime)[0]

		nrepetitions = fid.read(4)
		self.header['nrepetitions'] = unpack(self.i,nrepetitions)[0]

		acquisitiondelay = fid.read(4)
		self.header['acquisitiondelay'] = unpack(self.i,acquisitiondelay)[0]

		interstiminterval = fid.read(4)
		self.header['interstiminterval'] = unpack(self.i,interstiminterval)[0]

		self.header['creationdate'] = fid.read(16)

		self.header['datafilename'] = fid.read(64)

		self.header['orareserved'] = fid.read(256)

		if filesubtype == 11:
			# dyedag secific
			includesrefframe = fid.read(4) # 0 or 1
			self.header['includesrefframe'] = unpack(self.i,includerefframes)[0]

			self.header['temp'] = fid.read(128)

			self.header['listofstimuli']=temp[0:max(nonzero(temp!=0))]  # up to first non-zero stimulus
	
			ntrials = fid.read(4)
			self.header['ntrials'] = unpack(self.i,ntrials)[0]

			scalefactor = fid.read(4)
			self.header['scalefactor'] = unpack(self.i,scalefactor)[0] # bin * trials
	
			cameragain = fid.read(2)
			self.header['cameragain'] = unpack(self.h,cameragain)[0] # shcameragain        1,   2,   5,  10
	
			ampgain = fid.read(2)		    # amp gain            1,   4,  10,  16,
							    #                     40,  64, 100, 160,
							    #                     400,1000

			self.header['ampgain'] = unpack(self.h,ampgain)[0]

			samplingrate = fid.read(2)	    # sampling rate (1/x)
							    #                     1,   2,   4,   8,
							    #                     16,  32,  64, 128,
							    #                     256, 512,1024,2048
			self.header['samplingrate'] = unpack(self.h,samplingrate)[0]

			average = fid.read(2)		    # average             1,   2,   4,   8,
							    #                    16,  32,  64, 128
			self.header['average'] = unpack(self.h,average)[0]

			exposuretime = fid.read(2)	    # exposure time       1,   2,   4,   8,
							    #                     16,  32,  64, 128,
							    #                     256, 512,1024,2048
			self.header['exposuretime'] = unpack(self.h,exposuretime)[0]

			samplingaverage = fid.read(2)	    # sampling average    1,   2,   4,   8,
							    #                     16,  32,  64, 128
			self.header['samplingaverage'] = unpack(self.h,samplingaverage)[0]

			presentaverage = fid.read(2)
			self.header['presentaverage'] = unpack(self.h,presentaverage)[0]

			framesperstim = fid.read(2)
			self.header['framesperstim'] = unpack(self.h,framesperstim)[0]

			trialsperblock = fid.read(2)
			self.header['trialsperblock'] = unpack(self.h,trialsperblock)[0]

			sizeofanalogbufferinframes = fid.read(2)
			self.header['sizeofanalogbufferinframes'] = unpack(self.h,sizeofanalogbufferinframes)[0]

			cameratrials = fid.read(2)
			self.header['cameratrials'] = unpack(self.h,cameratrials)[0]

			self.header['filler'] = fid.read(106)

			self.header['dyedaqreserved'] = fid.read(256)

		else:
			# it's not dyedaq specific
			includesrefframe = fid.read(4)
			self.header['includesrefframe'] = unpack(self.i,includesrefframe)[0]

			self.header['listofstimuli'] = fid.read(256)

			nvideoframesperdataframe = fid.read(4)
			self.header['nvideoframesperdataframe'] = unpack(self.i,nvideoframesperdataframe)[0]

			ntrials = fid.read(4)
			self.header['ntrials'] = unpack(self.i,ntrials)[0]

			scalefactor = fid.read(4)
			self.header['scalefactor'] = unpack(self.i,scalefactor)[0]

			meanampgain = fid.read(4)
			self.header['meanampgain'] = unpack(self.i,meanampgain)[0]

			meanampdc = fid.read(4)
			self.header['meanampdc'] = unpack(self.i,meanampdc)[0]

			self.header['vdaqreserved'] = fid.read(256)

		self.header['user'] = fid.read(256)

		self.header['comment'] = fid.read(256)

		refscalefactor =fid.read(4)
		self.header['refscalefactor'] = unpack(self.i,refscalefactor)[0]
        		  # bin * trials for reference

		## End definitions of variables
		self.header['headersize']=fid.tell()
		fid.seek(0,2) # go to EOF
		self.header['actuallength'] = fid.tell() # report where EOF is in bytes

		fid.close()

		return self.header

	def get_data(self):
		"""Reads the data contained in the RSD file

		Returns
		-------
		data : numpy array
		    The data included in BLK file

		Raises
		------
		ValueError
		    If the headersize damaged
		RunTimeError
		    If data can't be read (the file is damaged)
		"""
		from struct import unpack
		import numpy as np

		filesize = self.header['filesize'] # Filesize extraction
		headersize = self.header['lenheader'] # Headersize extraction

		# Recuperation of image attributes
		xsize=self.header['framewidth']
		ysize=self.header['frameheidth']
		zsize=1
		tsize=self.header['nframesperstim']

		try:
			fid = open(self.filename,'r') # Opening data file
		except:
			print 'Cannot open file: ', filename # If file can't be read
			return

		try:
			a=fid.seek(headersize,0) # go to data
		except ValueError:
			print 'Cannot not seek to byte: ', headersize
			return

		try:
			data_in=fid.read() # Data recuperation
			self.data=unpack(str(int(self.H[0:-1])*(filesize-headersize)/2)+self.H[-1],data_in) # Data unpack
		except RuntimeError:
			print 'Cannot not read data'
			return

		fid.close()

		return self.data

	def get_4d_image(self, temporal_binning=1, spatial_binning=1):
		"""Transformation of data linear bitstream to a regular image 2D + time data

		Parameters
		----------
		temporal_binning : int, optional
		  Number of consecutive temporal samples to be averaged into the imported file
		spatial_binning : int, optional
		  Size (in pixels) of square window to be averaged into one pixel of the imported file

		Returns
		-------
		image : numpy array
		    The 2D + time data image
		"""
		import numpy as np

		f = open(self.filename,'r') # Opening file
		a = np.fromfile(file=f, dtype=np.short)
		f.close()

		# we know the size of the frames, we do not know the number of frames though...
		x_size = 128
		y_size = 100
		z_size=1
		t_size = a.size / (x_size * y_size)

		# reshape the data into a 4D nifti-compliant matrix
		a = a.reshape( [ t_size, z_size, y_size, x_size ] )

		# extract the useful part of the data (a priori knowledge)
		a = a[:,:,:,20:120]

		# add the first frame to all the other ones to recover the original signal (a priori knowledge)
		a = a[1:,:,:,:] + np.tile( a[0,:,:,:], (t_size-1,1,1,1) )
		
		if temporal_binning > 1:
			t_size_binned = int( np.ceil( float(t_size) / temporal_binning ) )
			b = np.zeros( [ t_size_binned, 1, a.shape[2], a.shape[3] ] )
			for t in range(t_size_binned):
				ind_min = t*temporal_binning
				ind_max = min ( (t+1)*temporal_binning, t_size )
				b[ t, 0, :, :] = a[ ind_min:ind_max, 0, :, :].mean(0).astype(int)
			a = b
		else:
			t_size_binned = t_size

		if spatial_binning > 1:
			s_size_binned = int( np.ceil( float(y_size) / spatial_binning ) )
			b = np.zeros( [ t_size_binned, 1, s_size_binned, s_size_binned] )
			for x in range(s_size_binned):
				ind_min_x = x * spatial_binning
				ind_max_x = min( (x+1) * spatial_binning, x_size)
				for y in range(s_size_binned):
					ind_min_y = y * spatial_binning
					ind_max_y = min( (y+1) * spatial_binning, y_size)
					b[:,0,y,x] = a[:,0,ind_min_y:ind_max_y,ind_min_x:ind_max_x].mean(-1).mean(-1).astype(int)
			a = b

		self.image = a

		'''
		xsize=self.header['framewidth']
		ysize=self.header['frameheidth']
		zsize=1
		tsize=self.header['nframesperstim']
		
		self.image = np.reshape(self.data,(tsize,zsize,ysize,xsize))
		'''

		return a
