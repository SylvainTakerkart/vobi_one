# Author: Philippe Katz <philippe.katz@gmail.com>,
#         Sylvain Takerkart <Sylvain.Takerkart@incm.cnrs-mrs.fr>
# License: BSD Style.

"""
This module contains the entire procedures and functions needed to process the linear model decomposition.
"""
## Arrays operations
from numpy import array, arange, ones, zeros, cos, sin, exp, hstack, nonzero, dot, transpose, argmax
## Maths functions
from math import pi, ceil, pow

def fourier_coeffs(N,f,time):
    """Creates fourier coefficients for environmental and physiological noise

    Parameters
    ----------
    N : int
        Fourier order of the corresponding frequency
    f : float
        Fondamental frequency
    time : vector
        Time vector


    Returns
    ----------
    X : array of float
        Concatenation of each oscillator component

    Notes
    ----------
    The fourier coefficients used are :math:`c_{n}^{k}=cos(2 n \pi f_{k} t)` and :math:`s_{n}^{k}=sin(2 n \pi k_{k} t)`.

    The output is then defined as the concatenation of column vectors :math:`c_{i}^{k}` and :math:`s_{i}^{k}`, :math:`i=[1 \dots N_{k}]` :
    
    .. math::

        X_{1}^{k}=[c_{1}^{k} \ s_{1}^{k} \dots c_{N_{k}}^{k} \ s_{N_{k}}^{k}]

    Examples
    ----------
    >>> from linear_model import fourier_coeffs
    >>> from numpy import arange
    >>> import param_conf as conf
    >>> time_vector=arange(0,(conf.dt),(1/conf.fe))
    >>> X1=fourier_coeffs(conf.N1,conf.f1,time_vector)
    >>> X1
    array([[ 1.        ,  0.        ,  1.        , ...,  0.        ,
             1.        ,  0.        ],
           [ 0.84125353,  0.54064082,  0.41541501, ...,  0.75574957,
            -0.95949297,  0.28173256],
           [ 0.41541501,  0.909632  , -0.65486073, ..., -0.98982144,
             0.84125353, -0.54064082],
           ..., 
           [-0.14231484, -0.98982144, -0.95949297, ..., -0.54064082,
            -0.65486073, -0.75574957],
           [ 0.41541501, -0.909632  , -0.65486073, ...,  0.98982144,
             0.84125353,  0.54064082],
           [ 0.84125353, -0.54064082,  0.41541501, ..., -0.75574957,
            -0.95949297, -0.28173256]])

    """

    X=zeros((time.shape[0],N*2)) # X1_k initialisation
    
    range_N=arange(1,N+1,1) # Creating a vector going from 1 to N with step = 1
    j=0
    for n in range_N: # from 1 to N
        X[:,j]=cos(2*pi*n*f*time) # Cosinus component
        X[:,j+1]=sin(2*pi*n*f*time) # Sinus component
        j=j+2
        
    return X

def mod_bruits(N,f,time):
    """Creates fourier coefficients of a list of frequencies and concatenates them into an array
    
    Parameters
    ----------
    N : list of int
                Fourier orders of the corresponding frequency
        f : list of float
                Fondamental frequencies
    time : vector
        Time vector

    Returns
    ----------
    X1 : array of float

    Notes
    ----------

    .. math::

        X_{1} = [X_{1,1} \ X_{1,2} \dots X_{1,k}]

    """

    i=0
    while i<(len(N)):
        X=fourier_coeffs(N[i],f[i],time) # Creating fourier coefficients

        if i==0:
            X1=X # X1 initialisation (for the first loop)
        else:
            X1=hstack((X1,X)) # Concatenation of X and X1
        i=i+1

    return X1

def dye_bleaching(tau,time):
    """
    Creates the exponential decrease of dye

    Parameters
    ----------
    tau : float
        Time constant of exponential decrease
    time : vector
        Time vector

    Returns
    ----------
    X2 : vector of int
        The exponential decrease
    """
    X2 = zeros( ( time.shape[0] , 1 ) ) # Vector initialisation. It has the same size as the time vector
    X2[:,0] = exp(-(time/tau)) - 1. # Creating of dye bleaching function

    return X2

def range_alpha_orig(alpha_min,alpha_max,time):
    """Create a time-range vector included between an alpha min and an alpha max

    Parameters
    ----------
    alpha_min : float
        The minimum time of the vector
    alpha_max : float
        The maximum time of the vector
    time : vector
        Time vector

    Returns
    -------
        alpha : vector
            Time-range vector
    """
    alpha=[] # alpha initialization
    i=0

    while i<len(alpha_min):
        alpha_i=[] # alpha_i initialization

        if alpha_min[i] == alpha_max[i]:
            # if one value only, then just use this one!
            alpha_i.append(alpha_min[i])
        else:
            if i<6:
                # time-range parameters: use philippe's method
                for t in time:
                    if t>alpha_min[i] and t<alpha_max[i]:
                        alpha_i.append(t)
                # add a safety check in case the min and max values are too close
                if len(alpha_i) == 0:
                    alpha_i.append(alpha_min[i])
                    alpha_i.append(alpha_max[i])
            else:
                # new amplitude parameters: use regular sampling
                step_numbers = 5
                for s in range(step_numbers):
                    alpha_i.append(alpha_min[i] + s * (alpha_max[i] - alpha_min[i]) / step_numbers)

        alpha_i=array(transpose([alpha_i]))
        alpha.append(alpha_i)
        i=i+1

    return alpha
    
def range_alpha(alpha_min,alpha_max,time):
    """Create a time-range vector included between an alpha min and an alpha max
    New version (STt 2012/10/24) to accelarate things: fixed number of example
    shapes are generated (around 10000); the number of steps for each parameter
    is automatically chosen to do so...

    Parameters
    ----------
    alpha_min : float
        The minimum time of the vector
    alpha_max : float
        The maximum time of the vector
    time : vector
        Time vector

    Returns
    -------
        alpha : vector
            Time-range vector
    """
    # we browse the parameters in the following way, to be efficient:
    # we will generate a constant number of simulated shapes, and compute
    # the step numbers, parameter by parameter, to generate this
    # for each type of parameters (the first 6 are temporal parameters, the last 2
    # are amplitude parameter), the parameter with the widest range is split into
    # 10 steps, and the other parameters are split proportionnally

    total_nbr_simulated_shapes = 10000

    # normalize parameter ranges in two range: the temporal parameters (first 6),
    # and the amplitude parameters (last 2)

    alpha_range = array(alpha_max) - array(alpha_min)

    normed_alpha_range = zeros(len(alpha_min))

    temp_max_index = argmax(alpha_range[0:6])
    amp_max_index = argmax(alpha_range[6:8]) + 6
    if alpha_range[temp_max_index]:
        for i in range(6):
            normed_alpha_range[i] = alpha_range[i] / alpha_range[temp_max_index]
    if alpha_range[amp_max_index]:
        for i in range(6,8):
            normed_alpha_range[i] = alpha_range[i] / alpha_range[amp_max_index]

    nonnull_range = normed_alpha_range[nonzero(normed_alpha_range)]

    if len(nonnull_range):

        c = 1. / nonnull_range.prod()
        
        e = 1. / len(nonnull_range)
        
        max_step_number = pow( c * total_nbr_simulated_shapes, e )
        
        step_numbers = zeros(len(alpha_min), dtype=int)
        for i in range(len(alpha_min)):
            step_numbers[i] = int(ceil(max_step_number * normed_alpha_range[i]))
            
        alpha=[] # alpha initialization
        i=0 # number of parameters (at the moment: there are 7 alpha parameters
        
        while i<len(alpha_min):
            alpha_i=[] # alpha_i initialization

            if alpha_min[i] == alpha_max[i]:
                # if one value only, then just use this one!
                alpha_i.append(alpha_min[i])
            else:
                for s in range(step_numbers[i]):
                    alpha_i.append(alpha_min[i] + s * (alpha_max[i] - alpha_min[i]) / step_numbers[i])

            alpha_i=array(transpose([alpha_i]))
            alpha.append(alpha_i)
            i=i+1

    else: # there's not actual range of parameters, the user wants to work with a single fixed shape
        alpha = alpha_min # which is equal to alpha_max


    return alpha
    
def range_alpha_light(alpha_range,time):
    """Creates a time-range vector with only min and max values of all alpha

    Parameters
    ----------
    alpha_range : time-range vector
        The time-range vector included between an alpha min and an alpha max
    time : vector
        Time vector

    Returns
    -------
    alpha_range_light : vector
        Time-range vector with only min and max values of all alpha
    """
    alpha_range_light=[]
    for i in range(len(alpha_range)):
        alpha_i=[]
        min_i=alpha_range[i][0][0]
        max_i=alpha_range[i][alpha_range[i].shape[0]-1][0]
        alpha_i.append(min_i)
        if min_i!=max_i:
            alpha_i.append(max_i)
        alpha_i=array(transpose([alpha_i]))
        alpha_range_light.append(alpha_i)
     
    return alpha_range_light


def concat_alpha(A,B):
    """Concatenates a matrix and a vector to one matrix

    Parameters
    ----------
    A : numpy array
        A matrix
    B : numpy vector
        A vector

    Returns
    -------
    alpha : numpy array
        The concatenation of A and B
    
    """
    
    alpha=zeros(((len(A)*len(B)),len(A[0])+1)) # alpha initialization

    i=0
    while i<len(B):
        alpha[i*len(A):(i+1)*len(A),0:len(A[0])]=A
        alpha[i*len(A):(i+1)*len(A),len(A[0])]=B[i,0]
        i=i+1

    return alpha

def mod_response(alpha,time):
    """Creates the example-shapes response

    Parameters
    ----------
    alpha : numpy vector
        The whole values that can take alpha
        Created by range_alpha(...)
    time : numpy vector
        Time vector

    Returns
    -------
    r_alpha : numpy array
        Response-shapes components
    """
    r_alpha=zeros((time.shape[0],len(alpha))) # r_alpha initialization
    
    range_size=arange(len(alpha)) # range_size initialization
    
    invalid=[] # Bad shapes list
    invalid_id=[] # Bad shapes identity list
    i=0 # Number of correct shape    
    for a in range_size: # For each shape
        if (alpha[a,0]+alpha[a,1]+alpha[a,2]+alpha[a,3]+alpha[a,4]+alpha[a,5])<time[-1]:

            # delay before the response starts: stays at zero
            c1=nonzero(time>alpha[a,0])

            # first part of the negative dip; amplitude is -beta = -alpha[,6]
            c2=nonzero(time>(alpha[a,0]+alpha[a,1]))
            r_alpha[c1[0][0]:c2[0][0],i] = alpha[a,6] * (cos(pi*((time[c1[0][0]:c2[0][0]]-alpha[a,0])/alpha[a,1])) - 1 ) / 2

            # rise from negative dip to plateau; amplitude of plateau is +1
            c3=nonzero(time>(alpha[a,0]+alpha[a,1]+alpha[a,2]))
            r_alpha[c2[0][0]:c3[0][0],i] = (1 - alpha[a,6]) / 2 - (1 + alpha[a,6]) * cos(pi*((time[c2[0][0]:c3[0][0]]-alpha[a,0]-alpha[a,1])/alpha[a,2])) / 2

            # plateau
            c4=nonzero(time>(alpha[a,0]+alpha[a,1]+alpha[a,2]+alpha[a,3]))
            r_alpha[c3[0][0]:c4[0][0],i]=1.

            # decrease from plateau to second negative dip: amplitude of dip is -gamma = -alpha[,7]
            c5=nonzero(time>(alpha[a,0]+alpha[a,1]+alpha[a,2]+alpha[a,3]+alpha[a,4]))
            r_alpha[c4[0][0]:c5[0][0],i] = (1 - alpha[a,7]) / 2 + (1 + alpha[a,7]) * cos(pi*((time[c4[0][0]:c5[0][0]]-alpha[a,0]-alpha[a,1]-alpha[a,2]-alpha[a,3])/alpha[a,4])) / 2

            # rise from second negative dip to rest activity (zero!)
            c6=nonzero(time>(alpha[a,0]+alpha[a,1]+alpha[a,2]+alpha[a,3]+alpha[a,4]+alpha[a,5]))
            r_alpha[c5[0][0]:c6[0][0],i] = - alpha[a,7] * (1 + cos(pi*((time[c5[0][0]:c6[0][0]]-alpha[a,0]-alpha[a,1]-alpha[a,2]-alpha[a,3]-alpha[a,4])/alpha[a,5])) ) / 2

            i=i+1 # Increase of correct shape
        else: # The shape is invalid
            invalid_id.append(a) # Add identity of bad shape
            invalid.append([alpha[a,0],alpha[a,1],alpha[a,2],alpha[a,3],alpha[a,4],alpha[a,5],alpha[a,6],alpha[a,7]]) # Add her values
    return r_alpha[:,0:i],invalid,invalid_id
    
def getMax(tab):
    """Return position of max in a tab
    """
    max=tab[0]
    pos=0
    j=0
    for i in tab:
        if tab[j]>=max:
            max=tab[j]
            pos=j
        j+=1
    return pos

def mod_response2(range_alpha,time):
    """Creates the example-shapes response

    Parameters
    ----------
    range_alpha : list of int
        The whole values that can take alpha
        Created by range_alpha(...)
    time : array of int
        Time vector

    Returns
    ----------
    r_alpha : array of int
        Example-shapes
    """
    r_alpha=zeros((time.shape[0],(len(range_alpha[0])*len(range_alpha[1])*len(range_alpha[2])*len(range_alpha[3])))) # r_alpha initialization
    i=0
    for alpha1 in range_alpha[0]: # For each alpha0
            for alpha2 in range_alpha[1]: # For each alpha1
                    for alpha3 in range_alpha[2]: # For each alpha2
                            for alpha4 in range_alpha[3]: # For each alpha3
                                    if (alpha1+alpha2+alpha3+alpha4)<time[-1]:
                        # delay before the response starts: stays at zero
                                            c1=nonzero(time>alpha1)
                        # rise from zero to plateau; amplitude of plateau is +1
                                            c2=nonzero(time>(alpha1+alpha2))
                                            r_alpha[c1[0][0]:c2[0][0],i]=(1-cos(pi*((time[c1[0][0]:c2[0][0]]-alpha1)/alpha2)))/2
                        # plateau
                                            c3=nonzero(time>(alpha1+alpha2+alpha3))
                                            r_alpha[c2[0][0]:c3[0][0],i]=1.
                        # decrease from plateau to zero
                                            c4=nonzero(time>(alpha1+alpha2+alpha3+alpha4))
                                            r_alpha[c3[0][0]:c4[0][0],i]=(1+cos(pi*((time[c3[0][0]:c4[0][0]]-alpha1-alpha2-alpha3)/alpha4)))/2
                                            i=i+1
    
    return r_alpha[:,0:i]



