# Author: Philippe Katz <philippe.katz@gmail.com>,
#         Sylvain Takerkart <Sylvain.Takerkart@univ-amu.fr>
# License: BSD Style.

# Imports
try:
    from neuroProcesses import * # Provides a hierarchy to get object's path
except ImportError:
    print 'Impossible to import neuroProcesses'
    
try:
    import os
except ImportError:
    print 'Impossible to import os'

try:
    import shutil
except ImportError:
    print 'Impossible to import shutil'

try:    
    from soma import aims
except ImportError:
    print 'Impossible to import PyNIFTI'
    
try:
    import oidata.glm as glm
except ImportError:
    print 'Impossible to import glm'

try:
    import numpy as np
except ImportError:
    print 'Impossible to import numpy'

try:
    import pickle
except ImportError:
    print 'Impossible to import pickle'

try:
    import oidata.blk_file as blk_file
except ImportError:
    print 'Impossible to import blk_file'

try:
    import oidata.rsd_file as rsd_file
except ImportError:
    print 'Impossible to import blk_file'

try:
    from neuroHierarchy import databases
except ImportError:
    print 'Impossible to import neuroHierarchy'
try:
    import matplotlib.pyplot as plt # Needed to plot data graph
except ImportError:
    raise ImportError('Impossible to import matplotlib.pyplot') # Raises an exception
    
# Header
userLevel=3 # Never visible

class OiTrial:
    """Trial-level class for optical imaging

    This class contains an ensemble of trial-level functions for imaging processing and structured saving.
    It can be used for some of these functions in database mode or in manual mode :

    * Database mode

    1. Used by entering a valid path, it checks that the path is valid, if not it returns a warning and saves in the path given by the user.
    2. Used without any path, it saves in using the path build by the function.

    * Manual mode

    It saves in the path given by the user without giving any warning message.

    Attributes
    ----------
    database : str
        Database's path
    protocol : str
        Protocol's name
    subject : str
        Subject's name
    session : str
        Session directory. Given by the prefix 'session_' and the session date.
    exp : str
        Experience directory
    trial : str
        Trial directory
    analysis : str
        The name of the analysis directory
    filename : str
        Image's filename
    format : {'.nii','.nii.gz'}
        Saving format of images. It can be NIFTI-1 Image ('.nii') or gzip compressed NIFTI-1 Image ('.nii.gz')
    database_mode : bool
        The database mode
    pathGLM : str
        The path returned by the last save function
    pathGLM_physio : str
        The path of glm+physiological parameters returned by the last save function
    extend : str
        The suffix of images' filename. Gives the processing algorithmes applied on this image. It can be :
        * '_f0d' for frame0 division
        * '_f0s' for frame0 subtraction
        * '_d' for linear detrend
        * '_bks' for blank subtraction
        * '_bkd' for blank division
    RAW_image : numpy array
        The raw image, without any processing
    head : dict
        The head of the BLK or RSD file
    output : dict
        Contains the different ouputs returned be the processing algorithmes : 'betas' the betas returned by the Linear Model, 'noise' the residual noise returned by the Linear Model, 'denoised' the image resulting of the Linear Model method, 'bksd' the image resulting of the bksd method
    X : numpy array
        The matrix of regressors
    L : int
        The number of regressors kept to apply the linear model
    nifti_header : dict
        The NIFTI-1 file's header

    Methods
    -------
    __init__( ... )
        Initializes class' attributes
    load_external_file( ... )
        Loads a data file, containing the raw image
    load_rawdata_and_model_definition( ... )
        Loads the raw image and the model definition
    load_bksd( ... )
        Loads a bksd image, obtained after processing the bksd method, and an averaged raw image
    load_raw( ... )
        Loads the raw image and modifies the path of analysis
    copy_rawdata_and_model_definition( ... )
        Copies the model definition from the session-level analysis directory to the trial-level directory
    get_raw( ... )
        Returns the RAW_image
    get_4d_image_field( ... )
        Returns the outputs
    set_raw_path( ... )
        Set the raw path
    set_nifti_header( ... )
        Set values to NIFTI-1 header
    set_model_parameters( ... )
        Loads parameters
    set_glm( ... )
        Loads Model's path
    create_model_definition( ... )
        Creates the matrix of regressors
    estimate_glm( ... )
        Estimation of input signal using the Linear Model
    denoise_data( ... )
        Input signal denoising
    frame0_division( ... )
        The frame0 division
    frame0_subtraction( ... )
        The frame0 subtraction
    linear_detrend( ... )
        The linear detrending
    blank_subtraction( ... )
        The blank subtraction
    blank_division( ... )
        The blank division
    save_model_definition( ... )
        Saves X.txt in session_level (in vsdi_data)
    save_model_parameters( ... )
        Saves param.npz in session_level (in vsdi_data)
    save_betas( ... )
        Saves betas as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI-1 Image)
    save_residuals( ... )
        Saves residual noise as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI
    save_denoised( ... )
        Saves denoised image as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI
    save_raw( ... )
        Saves raw image as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI-1 Image)
    save_bksd( ... )
        Saves image obtained by bksd method processing as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI-1 Image)
    update_database( ... )
        Register created files in brainvisa's database
    """

    def __init__( self,database=None,protocol=None,subject=None,session=None,exp=None,trial=None,analysis=None,format='.nii', database_mode=False, condition = None , period = None):
        """Initializes class' attributes

        Parameters
        ----------
        database : str, optional
            Database's path
        protocol : str, optional
            Protocol's name
        subject : str, optional
            Subject's name
        session : str, optional
            Session directory. Given by the prefix "session_" and the session date.
        exp : str, optional
            Experience directory
        trial : str, optional
            Trial directory
        analysis : str, optional
            The name of the analysis directory
        format : {'.nii','.nii.gz'}, optional
            Saving format of images. It can be NIFTI-1 Image ('.nii') or gzip compressed NIFTI-1 Image ('.nii.gz')
        database_mode : bool, optional
            The database mode
        """
        self.database = database
        self.protocol = protocol
        self.subject = subject
        self.session = session
        self.exp = exp
        self.trial = trial
        self.condition = condition
        self.analysis = analysis
        self.filename=''
        self.__setformat(format)
        self.database_mode=database_mode
        self.RAW_image=[]
        self.output={}
        self.pathGLM=''
        self.pathGLM_physio=''
        self.__pathRAW=None
        self.__pathAnalysis=None
        self.extend=''
        self.head={}
        self.X=None
        self.nbr_of_physio_regressors=None
        self.L=None
        self.set_nifti_header() # Set values to NIFTI-1 header
        self.current_img=None
        self.period = period # Period in s
        self.start=17 # Samples lag at the beginning 


    def load_external_file( self, external_file_path, temporal_binning=1, spatial_binning=1 ):
        """Loads a data file, containing the raw image

        ...

        Loads the raw image, coming from the acquisition system. It can be a RSD file or a BLK file.

        Parameters
        ----------
        external_file_path : str
            The path of the external file, containing the raw image
        temporal_binning : int, optional
            Number of consecutive temporal samples to be averaged into the imported file
        spatial_binning : int, optional
            Size (in pixels) of square window to be averaged into one pixel of the imported file

        """
        file_extension = external_file_path[-3:].upper() # Recuperation of file extension
        self.__set_external(external_file_path) # Initialization of __external_file_path using BLK or RSD data file's path

        if file_extension == 'BLK':
            this_file = blk_file.BlkFile( self.__external_file_path ) # Initialisation of BlkFile Class
        elif file_extension == 'RSD':
            this_file = rsd_file.RsdFile( self.__external_file_path ) # Initialisation of RsdFile Class

        self.RAW_image = this_file.get_4d_image(temporal_binning,spatial_binning) # Recuperation of raw data transformed to a regular image 2D + time data
        del this_file # Destruction of this_file instance

    def load_rawdata_and_model_definition( self ):
        """Loads the raw image and the model definition
        """
        self.__load_raw( self.__pathRAW ) # Loads a raw image from file
        self.X=np.loadtxt(os.path.join(self.__pathAnalysis,'glm.txt')) # Loads model definition matrix from file

        f=open(os.path.join(self.__pathAnalysis,'param.npz'),'r') # Opening parameters file
        self.L=pickle.load(f)[5] # Recuperation of L, the number of regressors used to define the denoised signal
        f.close() # Closing parameters file

    def load_bksd( self,path,path_average ):
        """Loads a bksd image, obtained after processing the bksd method, and an averaged raw image

        Parameters
        ----------
        path : str
            Bksd image path
        path_average : str
            The path of an image obtained after an averaging on raws images
        """
        self.load_raw( path ) # Loads the raw image and modifies the path of analysis
        self.__load_mean_blank( path_average ) # Loads a averaged raw image from file

    def load_raw( self,path ):
        """Loads the raw image and modifies the path of analysis

        Parameters
        ----------
        path : str
            The path of the raw image
        """
        self.__load_raw( path ) # Loads the raw image and modifies the path of analysis

        if self.database_mode==True: # If using the database mode, creation of a regular __pathAnalysis
            self.__pathAnalysis=os.path.join(self.database,self.protocol,self.subject,self.session,'oitrials_analysis',self.exp,self.trial,self.analysis,os.path.splitext(os.path.splitext(os.path.basename(path.encode("utf8")))[0])[0])

    def copy_rawdata_and_model_definition( self ):
        """Copies the model definition from the session-level analysis directory to the trial-level directory
        """
        if os.path.lexists(self.__pathAnalysis)==False: # If the path designed by __pathAnaysis does not exist
            os.makedirs(self.__pathAnalysis) # Creation of the path designed by __pathAnaysis

        # Copying the model definition file and the model parameters from session-level to trial-level
        shutil.copy(os.path.join(self.database,self.protocol,self.subject,self.session,'oisession_analysis',self.analysis,'glm.txt'),self.__pathAnalysis)
        shutil.copy(os.path.join(self.database,self.protocol,self.subject,self.session,'oisession_analysis',self.analysis,'param.npz'),self.__pathAnalysis)

    def get_raw( self ):
        """Returns the RAW_image

        Returns
        -------
        RAW_image : numpy array
            The raw image, without any processing
        """
        return self.RAW_image

    def get_4d_image_field( self ):
        """Returns the outputs

        Returns
        -------
        output : dict
            Contains the different ouputs returned be the processing algorithmes : 'betas' the betas returned by the Linear Model, 'noise' the residual noise returned by the Linear Model, 'denoised' the image resulting of the Linear Model method, 'bksd' the image resulting of the bksd method.
        """
        return self.output

    def set_raw_path( self, RAW_path ):
        """Set the raw path

        Parameters
        ----------
        RAW_path : str
            The path of raw image

        Returns
        -------
        warning : {0,-1}
            Takes as value : 0 if the path really exist, -1 if the path doesn't exist
        """
        warning = 0
        self.__set_raw( RAW_path ) # Initialization of __pathRAW attribute using the raw NIFTI image path

        if self.database_mode == True: # If using the database mode
            if self.analysis == None: # If no definition of analysis directory
                raise ValueError('Missing analysis') # raises an exception
            
            else:
                try:
                    self.__init_from_raw() # Initialization of path and directories attributes using the raw NIFTI image path
                    self.__set_path_analysis() # Initialization of __pathAnalysis using __pathRAW attribute
                except:
                    warning = -1
                    return warning # Returns a warning if the path does not correspond to the path created by the database mode
        return warning

    def set_nifti_header( self, period=1.0,time_units=8,xyz_units=2 ):
        """Set values to NIFTI-1 header

        Parameters
        ----------
        period : float, optional
            The acquisition period
        time_units : int, optional
            The time units
        xyz_units : int, optional
            The spatial units
        """
        self.nifti_header={'xyz_units':2, 'time_units':8, 'voxel_size':[1,1,1,period]}

    def set_model_parameters( self,param ):
        """Loads parameters

        Parameters
        ----------
        param : str or tuple
            The parameters used to create the Linear Model.
            It can be : a str, in case of the parameters are loaded from an existing file, param is the path of this file or a tuple, in case of the parameters are set manually.
              param is a tuple which contains :
              0. The sampling frequency,
              1. The trial duration,
              2. The time constant of dye bleaching,
              3. The frequencies of environmental and physiological noises (a list),
              4. The fourier orders of environmental and physiological noises (a list, must have the same lenght as point 3),
              5. The number of regressors kept to create the Linear Model,
              6. The time-range parameters (minima),
              7. The time-range parameters (maxima, must have the same lenght as point 6)
        """
        if type(param) is tuple:
            self.param = param
            self.L=self.param[5]

        elif type(param) is str: # If param is a path
            f=open(param,'r') # Opening parameters file
            self.param=pickle.load(param)
            self.L=self.param[5]
            f.close() # Closing parameters file

    def set_glm( self, path ):
        """Loads Model's path

        Parameters
        ----------
        path : str
            The path of the Linear Model

        Raises
        ------
        ValueError
            If extension of the file is different of '.txt'
        """

        if self.database_mode == True: # If using database mode
            if path != os.path.join(self.__pathAnalysis,'glm.txt'): # If the path is not the one created by the database mode
                if os.path.splitext(path)[1]!='.txt': # If the file is not a txt file
                    raise ValueError('File extension not supported for %s: extension should be .txt)' % path) # Raises an exception
                else:
                    self.pathGLM = path # Recuperation of path in pathGLM
                    warning = -1 # Returns a warning if the path does not correspond to the path created by the database mode
            else:
                warning = 0
                self.pathGLM = path # Recuperation of path in pathGLM

        else:
            if os.path.splitext(path)[1]!='.txt': # If the file is not a txt file
                raise ValueError('File extension not supported for %s: extension should be .txt' % path) # Raises an exception
            else:
                self.pathGLM = path # Recuperation of path in pathGLM  
        
    def average_region( self ):
        """Averages a region of an image

        Returns
        -------
        averaged_region : numpy vector
            The time serie resulting from the averaging of a region of interest
        """
        try: 
            roi=self.current_img*self.mask # Multiplies averaged image and mask for region of interest recovery
        except ValueError: # If shapes are not the same
            raise ValueError('The shapes of the mask ('+str(self.mask.shape)\
                       +') and the raw image ('+str(self.current_img.shape)+') are not the same => Mask can\'t be apply')
                       
        self.averaged_region = np.mean( roi,axis=2 ) # x axis averaging
        self.averaged_region = np.mean( self.averaged_region,axis=2 ) # y axis averaging
        return self.averaged_region 

    def getMax(self,*signals):
        """ Gets maximum of a signals list
        """
        maxi=0 # Maximum initialization
        for signal in signals: # For each signal
            maxi=max(np.array(signal).max(),maxi) # Update maximum
        return maxi
        
    def getMin(self,*signals):
        """ Gets minimum of a signals list
        """
        mini=0 # Minimum initialization
        for signal in signals: # For each signal
            mini=min(np.array(signal).min(),mini) # Update minimum
        return mini
        
    def estimate_glm( self ):
        """Estimation of input signal using the Linear Model

        Estimates the input signal and the residual noise
        """
        # Recuperation of image's size
        tsize=self.RAW_image.shape[0]
        zsize=self.RAW_image.shape[1]
        ysize=self.RAW_image.shape[2]
        xsize=self.RAW_image.shape[3]

        # Reshape of image from a time + 3D image to a time + 1D image (time,x*y*z)
        tmp_image = np.reshape(self.RAW_image,(tsize,zsize*ysize*xsize))

        # Application of Linear Model, recuperation of betas
        self.output["betas"]=glm.glm(tmp_image,self.X,method='ols').beta
        
        # Estimation of the whole signal (signal+noise)
        estimation=np.dot(self.X,self.output["betas"])

        self.output["noise"]=tmp_image.copy()-estimation.copy() # Recuperation of residual noise

        self.output["betas"] = np.reshape(self.output["betas"],(self.X.shape[1],zsize,ysize,xsize)) # Recuperation of betas and reshape from a time + 1D image to a time + 3D image (time,x,y,z)
        self.output["noise"] = np.reshape(self.output["noise"],(tsize,zsize,ysize,xsize)) # Reshape from a time + 1D image to a time + 3D image (time,x,y,z)
        
    def denoise_data( self ):
        """Input signal denoising
        """
        # Recuperation of image's size
        tsize=self.output["noise"].shape[0]
        zsize=self.output["noise"].shape[1]
        ysize=self.output["noise"].shape[2]
        xsize=self.output["noise"].shape[3]

        betas = np.reshape(self.output["betas"],(self.X.shape[1],zsize*ysize*xsize)) # Reshape of betas from a time + 3D image to a time + 1D image (time,x*y*z)
        residuals = np.reshape(self.output["noise"],(tsize,zsize*ysize*xsize)) # Reshape of residual noise from a time + 3D image to a time + 1D image (time,x*y*z)

        # signal = L last regressors in the model! remove everything else to denoise it!
        #signal=np.dot(self.X[:,self.X.shape[1]-self.L:self.X.shape[1]],betas[self.X.shape[1]-self.L:self.X.shape[1]])
        first_ind_response = self.X.shape[1]-self.L
        last_ind_response = self.X.shape[1]
        neural_response=np.dot(self.X[:,first_ind_response:last_ind_response],betas[first_ind_response:last_ind_response])
       
        # Reconstruction of denoised signal
        reconstr=(neural_response+residuals)/betas[0,:] # Adding residual noise to denoised signal, normalization with betas[0] (corresponds to the offset)
        denoised_signal=reconstr.copy() # Copy of reconstr (see numpy help for the use of copy in matrix)

        denoised_signal=np.reshape(denoised_signal,(tsize,zsize,ysize,xsize)) # Reshape from a time + 1D image to a time + 3D image (time,x,y,z)
        
        denoised_signal=(np.isnan(denoised_signal)).choose(denoised_signal,0).copy() # Remplacement of NaN by 0

        self.output["denoised"]=(np.isinf(denoised_signal)).choose(denoised_signal,0).copy() # Remplacement of Inf by 0
        
    def denoise_data_with_physio_glm( self ):
        """Input signal denoising
        """
        # Recuperation of image's size
        tsize=self.output["noise"].shape[0]
        zsize=self.output["noise"].shape[1]
        ysize=self.output["noise"].shape[2]
        xsize=self.output["noise"].shape[3]

        betas = np.reshape(self.output["betas"],(self.X.shape[1],zsize*ysize*xsize)) # Reshape of betas from a time + 3D image to a time + 1D image (time,x*y*z)
        residuals = np.reshape(self.output["noise"],(tsize,zsize*ysize*xsize)) # Reshape of residual noise from a time + 3D image to a time + 1D image (time,x*y*z)

        # signal = L last regressors in the model! remove everything else to denoise it!
        first_ind_response = self.X.shape[1]-self.L-self.nbr_of_physio_regressors
        last_ind_response = self.X.shape[1]-self.nbr_of_physio_regressors
        signal=np.dot(self.X[:,first_ind_response:last_ind_response],betas[first_ind_response:last_ind_response,:])
        
        # Reconstruction of denoised signal
        reconstr=(signal+residuals)/betas[0,:] # Adding residual noise to denoised signal, normalization with betas[0] (corresponds to the offset)
        denoised_signal=reconstr.copy() # Copy of reconstr (see numpy help for the use of copy in matrix)

        denoised_signal=np.reshape(denoised_signal,(tsize,zsize,ysize,xsize)) # Reshape from a time + 1D image to a time + 3D image (time,x,y,z)
        
        denoised_signal=(np.isnan(denoised_signal)).choose(denoised_signal,0).copy() # Remplacement of NaN by 0

        self.output["denoised"]=(np.isinf(denoised_signal)).choose(denoised_signal,0).copy() # Remplacement of Inf by 0

    def plot_decomposition(self):
        """ Signals data recovery
        """
        # Recuperation of image's size
        tsize=self.output["noise"].shape[0]
        zsize=self.output["noise"].shape[1]
        ysize=self.output["noise"].shape[2]
        xsize=self.output["noise"].shape[3]
        
        # Recovery of betas
        betas=np.reshape(self.output['betas'],(self.X.shape[1],zsize*ysize*xsize))
        # Recovery of denoised signal
        self.current_img=self.output['denoised']
        denoised=self.average_region()
        
        # Recovery of residuals
        signal=np.reshape(self.output['noise'],(tsize,zsize*ysize*xsize))
        #reconstr=signal/betas[0].mean()
        reconstr=signal/betas[0,:]
        signal=reconstr.copy() # Copy of reconstr (see numpy help for the use of copy in matrix)

        signal=np.reshape(signal,(tsize,zsize,ysize,xsize)) # Reshape from a time + 1D image to a time + 3D image (time,x,y,z)
        
        signal=(np.isnan(signal)).choose(signal,0).copy() # Remplacement of NaN by 0

        self.current_img=(np.isinf(signal)).choose(signal,0).copy() # Remplacement of Inf by 0
        residuals=self.average_region()
        
        # Creation of estimated response
        estimated_response=denoised-residuals # Estimated response
        estimated_response=np.reshape(estimated_response,(tsize))
        denoised=np.reshape(denoised,(tsize))    
        residuals=np.reshape(residuals,(tsize))
        
        # Creation of estimated noise
        signal=np.dot(self.X[:,1:self.X.shape[1]-self.L]\
                          ,betas[1:self.X.shape[1]-self.L])
        #reconstr=signal/betas[0].mean()
        reconstr=signal/betas[0,:]
        signal=reconstr.copy() # Copy of reconstr (see numpy help for the use of copy in matrix)

        signal=np.reshape(signal,(tsize,zsize,ysize,xsize)) # Reshape from a time + 1D image to a time + 3D image (time,x,y,z)
        
        signal=(np.isnan(signal)).choose(signal,0).copy() # Remplacement of NaN by 0

        self.current_img=(np.isinf(signal)).choose(signal,0).copy() # Remplacement of Inf by 0
        av=self.average_region()
        estimated_noise = np.reshape(av,(len(av)))
        
        # Recovery of raw signal
        signal=np.reshape(self.RAW_image,(tsize,zsize*ysize*xsize))
        #reconstr=signal/betas[0].mean()
        reconstr=signal/betas[0,:]
        signal=reconstr.copy() # Copy of reconstr (see numpy help for the use of copy in matrix)

        signal=np.reshape(signal,(tsize,zsize,ysize,xsize)) # Reshape from a time + 1D image to a time + 3D image (time,x,y,z)
        
        signal=(np.isnan(signal)).choose(signal,0).copy() # Remplacement of NaN by 0

        self.current_img=(np.isinf(signal)).choose(signal,0).copy() # Remplacement of Inf by 0
        raw=self.average_region()
        
        # Recovery of mean raw
        raw_mean=raw.mean()
        
        # Creation of raw demeaned signal
        raw_dem=raw-raw_mean # Raw signal demeaned       
        raw_dem=np.reshape(raw_dem,(tsize))
        
        # Creation of full estimated demeaned response
        signal=np.dot(self.X,betas)
        #reconstr=signal/betas[0].mean() # Reconstructed full estimated signal
        reconstr=signal/betas[0,:]
        signal=reconstr.copy() # Copy
        
        signal=np.reshape(signal,(tsize,zsize,ysize,xsize)) # Reshape after calcul
        
        signal=(np.isnan(signal)).choose(signal,0).copy() # Remplacement of NaN by 0

        self.current_img=(np.isinf(signal)).choose(signal,0).copy() # Remplacement of Inf by 0
        av=self.average_region()-raw_mean
        full_estimated = np.reshape(av,(tsize)) # Estimated response + estimated noise components  

        # Calcul of min and max of data graph
        maxi=self.getMax(estimated_response,estimated_noise\
                    ,full_estimated,raw_dem,residuals,denoised) # Gets the lowest value of all signals
        mini=self.getMin(estimated_response,estimated_noise\
                    ,full_estimated,raw_dem,residuals,denoised) # Gets the highest value of all signals                

        # Data graph construction
        self.fig = plt.figure() # Creates a data graph
        self.axes = self.fig.add_subplot(111) # Add a new graphic display
        self.axes.hold(True) # Sets the axes hold state
               
        # Draws signals
        t=np.linspace(-self.start*self.period*1000,(tsize-self.start)*self.period*1000,tsize)
        self.axes.plot(t,estimated_response,'b',t,estimated_noise,'r'\
                      ,t,full_estimated,'k',t,raw_dem,'c'\
                      ,t,residuals,'g',t,denoised,'y') # Plots
        self.axes.hold(False) # Sets the hold state of axes to false
        
        # Draws legend
        self.leg_names=('estimated response','noise components'\
                       ,'full estimate (demeaned)','raw signal (demeaned)'\
                       ,'residuals','denoised')
        box=self.axes.get_position()
        if len(self.leg_names)<3:
            ncol=len(self.leg_names)
        else:
            ncol=3
        self.axes.set_position([box.x0,box.y0+box.height*0.2,box.width,box.height*0.8])
        leg=self.axes.legend(self.leg_names,'upper center'\
                            ,bbox_to_anchor=(0.5, -0.1)\
                            ,fancybox=True\
                            ,shadow=True\
                            ,ncol=ncol)
        
        for t in leg.get_texts():
            t.set_fontsize('small') # Sets the size of text legend
    
        for l in leg.get_lines():
            l.set_linewidth(1.5) # Sets the width of line signal legend
            
        # Adjust limits                    
        if mini<0: # Define min vertical limit
            mini=mini*1.1
        else:
            mini=mini*0.9
        if maxi<0: # Define max vertical limit
            maxi=maxi*0.9
        else:
            maxi=maxi*1.1           
        self.axes.set_ylim([mini,maxi]) # Sets the vertical limits
        
        self.axes.set_xlim([-self.start*self.period*1000,(tsize-self.start)*self.period*1000]) # Sets horizontal limits        
        # Defines data graph properties
        self.axes.grid(True) # Shows the grid 
        self.axes.set_xlabel('Time') # Sets horizontal title
        # The following line will be uncommented with BrainVISA 4.4 with a more recent version of matplotlib
        #self.axes.set_ylabel(r'$\Delta$'+'F/F') # Sets vertical title
        self.axes.set_ylabel('Normalized signal') # Sets vertical title
        # The following line will be uncommented with BrainVISA 4.4 with a more recent version of matplotlib
        #self.axes.set_ylabel(r'$\alpha$')
        #self.axes.set_ylabel('alpha')
        # Trial informations recovery
        data=os.path.split(self.__pathRAW)[1]
        date=data[1:7] # Gets date's file
        exp=data[9:11] # Gets experiment's file
        trial=data[13:17] # Gets trial's file
        cdt=data[19:22] # Gets conditions' file
        
        # Sets title             
        self.axes.set_title('Signal Decomposition ; Date: '+date\
                               +' ; Experiment: '+exp+' ; Trial: '+trial\
                               +'\nCondition: '+cdt+' ; Region: '+self.mask_name) # Sets the data graph title    
        
                   
    def frame0_division(self,image,window ):
        """The frame0 division

        Parameters
        ----------
        image : numpy array
            The input image
        window : list
            The datas of a time serie used to divide the global time serie (time1,time2)
        """
        frame0=self.__frame0_construction( image,window ) # Does the mean of the time serie's datas included in a time window
        image=image/frame0 # Image division by the frame0

        image=(np.isnan(image)).choose(image,0).copy() # Remplacement of NaN by 0
        self.output["bksd"]=(np.isinf(image)).choose(image,0).copy() # Remplacement of Inf by 0

        self.extend=self.extend+'_f0d' # Adding to extend attribute '_f0d' as an extension (shows that a frame0 division as been done on this image)

    def frame0_subtraction( self,image,window ):
        """The frame0 subtraction

        Parameters
        ----------
        image : numpy array
            The input image
        window : list
            The datas of a time serie used to substract the global time serie (time1,time2)
        """
        frame0=self.__frame0_construction( image,window ) # Does the mean of the time serie's datas included in a time window
        self.output["bksd"]=image-frame0 # Image subtraction by the frame0
        self.extend=self.extend+'_f0s' # Adding to extend attribute '_f0s' as an extension (shows that a frame0 subtraction as been done on this image)

    def linear_detrend( self,image,window0,window1 ):
        """The linear detrending

        Parameters
        ----------
        image : numpy array
            The input image
        window0 : list
            The datas at the begin of a time serie used to detrend the global time serie (time1,time2)
        window1 : list
            The datas at the end of a time serie used to detrend the global time serie (time1,time2)
        """
        time_vector=np.arange(0,image.shape[0]) # Creation of time vector
        (a,b)=self.__linear_equation( image,window0,window1 ) # Construction of affine equation parameters

        # Recuperation of image's size
        tsize=image.shape[0]
        zsize=image.shape[1]
        ysize=image.shape[2]
        xsize=image.shape[3]

        line=np.dot(np.reshape(time_vector,(tsize,1)),np.reshape(a,(1,zsize*ysize*xsize)))+np.reshape(b,(1,zsize*ysize*xsize)) # Creation of line (a*image+b)

        image=np.reshape(image,(tsize,zsize*ysize*xsize)) # Reshape from a time + 1D image to a time + 3D image (time,x*y*z)
        
        image=image-line # Detrending
        self.output["bksd"]=np.reshape(image,(tsize,zsize,ysize,xsize)) # Reshape from a time + 1D image to a time + 3D image (time,x,y,z)
        self.extend=self.extend+'_d' # Adding to extend attribute '_d' as an extension (shows that a linear detrend as been done on this image)

    def blank_subtraction( self,image ):
        """The blank subtraction

        Parameters
        ----------
        image : numpy array
            The input image
        """
        self.output["bksd"]=image-self.mean_blank_image # subtraction of image by the averaging of blank images
        self.extend=self.extend+'_bks' # Adding to extend attribute '_bks' as an extension (shows that a blank subtraction as been done on this image)

    def blank_division( self,image ):
        """The blank division

        Parameters
        ----------
        image : numpy array
            The input image
        """

        image=image/self.mean_blank_image # Division of image by the averaging of blank images

        image=(np.isnan(image)).choose(image,0).copy() # Remplacement of NaN by 0
        self.output["bksd"]=(np.isinf(image)).choose(image,0).copy() # Remplacement of inf by 0

        self.extend=self.extend+'_bkd' # Adding to extend attribute '_bkd' as an extension (shows that a blank division as been done on this image)

    def gen_cos_sin(self,time_vector,params,freqcard,freqresp,dephcard,dephresp):
        """Creates fourier coefficients for physiological noise with frequency and physiological phases 

        Parameters
        ----------
        for N :int
            Fourier order of the corresponding frequency
        f : float
            Fondamental frequency
        time : vector
            Time vector
        params[4]:orders
        params[3]:frequencies

        Returns
        ----------
        X : array of float
        Concatenation of each oscillator component

        X4 : array of float

        """
        fourierorders=1 #eval(manip_char.standardize(params[4]))

        X=np.zeros((time_vector.shape[0],fourierorders*2)) # X1_k initialisation import model_definition

        Xhb=np.zeros((time_vector.shape[0],fourierorders*2))
        Xresp=np.zeros((time_vector.shape[0],fourierorders*2))

        range_fourierorders=np.arange(1,fourierorders+1,1) # Creating a vector going from 1 to N with step = 1
     
        for n in range_fourierorders: # from 1 to N
            j=n-1
            Xhb[:,j]=np.cos(2*np.pi*n*freqcard*time_vector) # Cosinus component
            Xhb[:,j+1]=np.sin(2*np.pi*n*freqcard*time_vector) # Sinus component
            Xresp[:,j]=np.cos(2*np.pi*n*freqresp*time_vector) # Cosinus component
            Xresp[:,j+1]=np.sin(2*np.pi*n*freqresp*time_vector) # Sinus component
               
        Xphysio=np.hstack((Xhb,Xresp))

        return Xphysio

    def save_model_definition( self,path=None ):
        """Saves X.txt in session_level (in vsdi_data)

        Parameters
        ----------
        path : str, optional
            The path where the model definition will be saved

        Returns
        -------
        warning : {0,-1}
            Takes as value : 0 if the path really exist, -1 if the path doesn't exist
        pathGLM : str
            The path where the model definition is saved

        Raises
        ------
        ValueError
            If the path does not exist
        """
        warning=0

        if self.database_mode==False: # If not using the database mode
            if path == None: # If no path defined
                raise ValueError('Path argument not defined') # Raises an exception
            else:
                pathGLM=path # Recuperation of path

        else:
            pathGLM=os.path.join(self.__pathAnalysis,'glm.txt') # pathGLM creation

            if path != None:
                if path != pathGLM: 
                    #print path
                    #print pathGLM
                    warning=-1 # Returns a warning if the path does not correspond to the path created by the database mode
                pathGLM=path

        if os.path.lexists(os.path.split(pathGLM)[0]) == False and os.path.split(pathGLM)[0] != '': # If pathGLM does not exist
            os.makedirs(os.path.split(pathGLM)[0]) # Creation of path

        np.savetxt(pathGLM,self.X) # Save of model definition in a txt file

        return (warning,pathGLM)

    def save_model_parameters( self,path=None ):
        """Saves param.npz in session_level (in vsdi_data)

        Parameters
        ----------
        path : str, optional
            The path where to save the model parameters
            

        Returns
        -------
        warning : {0,-1}
            Takes as value : 0 if the path really exist, -1 if the path doesn't exist
        path : str
            The path of the model parmeters

        Raises
        ------
        ValueError
            If the path does not exist
        """
        warning=0
        if self.database_mode==False: # If not using the database mode
            if path == None: # If no path defined
                raise ValueError('Path argument not defined') # Raises an exception
            else:
                pathParam=path # Recuperation of path
        else:
            pathParam=os.path.join(self.__pathAnalysis,'param.npz')
            if path != None:
                if path != pathParam:
                    #print path
                    #print pathParam
                    warning=-1 # Returns a warning if the path does not correspond to the path created by the database mode
                pathParam=path

        if os.path.lexists(os.path.split(pathParam)[0]) == False and os.path.split(pathParam)[0] != '': # If pathGLM does not exist
            os.makedirs(os.path.split(pathParam)[0]) # Creation of path

        f=open(pathParam.encode("utf8"),'w') # Save of model definition in a npz file
        pickle.dump(self.param,f)
        f.close()

        return (warning,path)

    def save_betas( self,path=None ):
        """Saves betas as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI-1 Image)

        Parameters
        ----------
        path : str, optional
            The path where to save the betas
            

        Returns
        -------
        warning : {0,-1}
            Takes as value : 0 if the path really exist, -1 if the path doesn't exist
        path : str
            The path of the betas

        Raises
        ------
        ValueError
            If the path does not exist,
            If extension of file is different of '.nii', '.nii.gz'
        """
        warning=0

        if self.database_mode==False: # If not using the database mode
            if path == None: # If no path defined
                raise ValueError('Path argument not defined') # Raises an exception
            elif os.path.splitext(path)[1] != '.nii' and os.path.splitext(os.path.splitext(path)[0])[1]+os.path.splitext(path)[1] != '.nii.gz': # If file extension if not nii or nii.gz
                raise ValueError('File extension not supported for %s: extension should be .nii or .nii.gz' % path) # Raises an exception

        else:
            pathBeta=os.path.join(self.__pathAnalysis,os.path.splitext(os.path.splitext(os.path.split(self.__pathRAW)[1])[0])[0] + '_betas' + self.format) # pathBetas Creation

            if path != None:
                if path != pathBeta:
                    #print path
                    #print pathBeta
                    warning=-1 # Returns a warning if the path does not correspond to the path created by the database mode
            else:
                path=pathBeta

        # NIFTI header creation
        nifti_header = self.nifti_header.copy()
        nifti_header[ 'time_units' ]=0
        nifti_header[ 'voxel_size' ]=[1,1,1,1]
        self.__save_nifti( path,self.output["betas"], nifti_header ) # Save of NIFTI-1 image

        return (warning,path)

    def save_residuals( self,path=None ):
        """Saves residual noise as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI-1 Image)

        Parameters
        ----------
        path : str, optional
            The path where to save the residual noise
            

        Returns
        -------
        warning : {0,-1}
            Takes as value : 0 if the path really exist, -1 if the path doesn't exist
        path : str
            The path of the residual noise

        Raises
        ------
        ValueError
            If the path does not exist
            If extension of file is different of '.nii', '.nii.gz'
        """
        warning=0

        if self.database_mode==False: # If not using the database mode
            if path == None: # If no path defined
                raise ValueError('Path argument not defined') # Raises an exception
            elif os.path.splitext(path)[1] != '.nii' and os.path.splitext(os.path.splitext(path)[0])[1]+os.path.splitext(path)[1] != '.nii.gz': # If file extension if not nii or nii.gz
                raise ValueError('File extension not supported for %s: extension should be .nii or .nii.gz' % path) # Raises an exception

        else:
            pathResiduals=os.path.join(self.__pathAnalysis,os.path.splitext(os.path.splitext(os.path.split(self.__pathRAW)[1])[0])[0] + '_residuals' + self.format) # pathResiduals Creation

            if path != None:
                if path != pathResiduals:
                    #print path
                    #print pathResiduals
                    warning=-1 # Returns a warning if the path does not correspond to the path created by the database mode
            else:
                path=pathResiduals

        self.__save_nifti( path,self.output["noise"], self.nifti_header ) # Save of NIFTI-1 image

        return (warning,path)

    def save_denoised( self,path=None ):
        """Saves denoised image as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI-1 Image)

        Parameters
        ----------
        path : str, optional
            The path where to save the denoised image
            

        Returns
        -------
        warning : {0,-1}
            Takes as value : 0 if the path really exist, -1 if the path doesn't exist
        path : str
            The path of the denoised image

        Raises
        ------
        ValueError
            If the path does not exist
            If extension of file is different of '.nii', '.nii.gz'
        """
        warning=0

        if self.database_mode==False: # If not using the database mode
            if path == None: # If no path defined
                raise ValueError('Path argument not defined') # Raises an exception
            elif os.path.splitext(path)[1] != '.nii' and os.path.splitext(os.path.splitext(path)[0])[1]+os.path.splitext(path)[1] != '.nii.gz': # If file extension if not nii or nii.gz
                raise ValueError('File extension not supported for %s: extension should be .nii or .nii.gz' % path) # Raises an exception

        else:
            pathDenoised=os.path.join(self.__pathAnalysis,os.path.splitext(os.path.splitext(os.path.split(self.__pathRAW)[1])[0])[0] + '_denoised' + self.format) # pathResiduals Creation

            if path != None:
                if path != pathDenoised:
                    #print path
                    #print pathDenoised
                    warning=-1 # Returns a warning if the path does not correspond to the path created by the database mode

            else:
                path=pathDenoised

        self.__save_nifti( path,self.output["denoised"], self.nifti_header ) # Save of NIFTI-1 image

        return (warning,path)

    def save_raw( self,path=None ):
        """Saves raw image as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI-1 Image)

        Parameters
        ----------
        path : str, optional
            The path where to save the raw image

        Returns
        -------
        warning : {0,-1}
            Takes as value : 0 if the path really exist, -1 if the path doesn't exist
        path : str
            The path of the raw image

        Raises
        ------
        ValueError
            If the path does not exist
            If extension of file is different of '.nii', '.nii.gz'
        """
        warning=0

        if self.database_mode==False: # If not using the database mode
            if path == None: # If no path defined
                raise ValueError('Path argument not defined') # Raises an exception
            else:
                self.__pathRAW=None

        else: # Using the database mode
            if path == None:
                # should never happen!
                self.__set_path_raw() # Setting __pathRAW attribute using path and directories attributes
            
            '''    
            self.__set_path_raw()

            if path != None:
                if path != self.__pathRAW:
                    print path
                    print self.__pathRAW
                    warning=-1

            else:
                path=self.__pathRAW
            '''


        self.__save_nifti( path,self.RAW_image,self.nifti_header ) # Save of NIFTI-1 image

        return (warning,path)

    def save_bksd( self,path=None ):
        """Saves image obtained by bksd method processing as a NIFTI image (NIFTI-1 Image or gzip compressed NIFTI-1 Image)

        Parameters
        ----------
        path : str, optional
            The path where to save the bksd image
            

        Returns
        -------
        warning : {0,-1}
            Takes as value : 0 if the path really exist, -1 if the path doesn't exist
        path : str
            The path of the bksd image

        Raises
        ------
        ValueError
            If the path does not exist
            If extension of file is different of '.nii', '.nii.gz'
        """
        warning=0

        if self.database_mode==False: # If not using the database mode
            if path == None: # If no path defined
                raise ValueError('Path argument not defined') # Raises an exception
            elif os.path.splitext(path)[1] != '.nii' and os.path.splitext(os.path.splitext(path)[0])[1]+os.path.splitext(path)[1] != '.nii.gz': # If file extension if not nii or nii.gz
                raise ValueError('File extension not supported for %s: extension should be .nii or .nii.gz' % path) # Raises an exception

        else:
            pathbksd=os.path.join(self.__pathAnalysis+self.extend+self.format) # pathbksd creation

            if path != None:
                if path != pathbksd:
                    #print path
                    #print pathbksd
                    warning=-1 # Returns a warning if the path does not correspond to the path created by the database mode

            else:
                path=pathbksd

        self.__save_nifti( path,self.output["bksd"], self.nifti_header ) # Save of NIFTI-1 image

        return (warning,path)
        
    def save_data_graph(self,path_data_graph):
        """Saves the data graph of spectral analysis as an PNG image
        """
        self.fig.savefig(path_data_graph,format='png')

    def update_database( self,path=None ):
        """Register created files in brainvisa's database

        Parameters
        ----------
        path : str, optional
            The path of the directory containing datas to update

        Returns
        -------
        warning : {0,-1}
            Takes as value : 0 if the path really exist, -1 if the path doesn't exist
        """
        warning = 0

        if path == None: # If no path defined, updating the whole database
            db=databases.database( self.database ) # Loading database
            # Updating directories
            db.update( self.__pathRAW )
            db.update( self.__pathAnalysis )

        elif path != None:
            if os.path.lexists( path ): # If path exists
                db=databases.database( self.database ) # Loading database
                db.update( path ) # Updating the defined directory
            else:
                warning = -1  # Returns a warning if path does not exists
                return warning
        else:
            warning = -1
            return warning

        return warning

    def __load_raw( self,path ):
        """Loads a raw image from file

        Parameters
        ----------
        path : str
            The path of the raw image
        """
        fname = path.encode("utf8")
        Vol = aims.read(fname) # Opening NIFTI file
        # NIFTI header recuperation
        self.nifti_header['xyz_units'] = Vol.header()['xyz_units']
        self.nifti_header[ 'time_units' ] = Vol.header()[ 'time_units' ]
        self.nifti_header[ 'voxel_size' ] = Vol.header()[ 'voxel_size' ]
        if self.period is None:
            self.period = self.nifti_header['voxel_size'][3]
        self.RAW_image=np.transpose(np.array( Vol,copy=True )) # Image recuperation

    def __load_mean_blank( self,path_average ):
        """Loads a averaged raw image from file

        Parameters
        ----------
        path_average : str
            The path of the averaged raw image
        """
        fname = path_average.encode("utf8")
        Vol = aims.read(fname) # Opening NIFTI file
        # NIFTI header recuperation
        self.nifti_header['xyz_units'] = Vol.header()['xyz_units']
        self.nifti_header[ 'time_units' ] = Vol.header()[ 'time_units' ]
        self.nifti_header[ 'voxel_size' ] = Vol.header()[ 'voxel_size' ]
        if self.period is None:
            self.period = self.nifti_header['voxel_size'][3]
        self.mean_blank_image=np.transpose(np.array( Vol,copy=True )) # Image recuperation

    def __init_from_raw( self ):
        """Initialization of path and directories attributes using the raw NIFTI image path
        """
        self.filename=os.path.split(os.path.splitext(os.path.splitext(self.__pathRAW)[0])[0])[1]
        self.trial=os.path.split(os.path.split(os.path.split(self.__pathRAW)[0])[0])[1]
        self.exp=os.path.split(os.path.split(os.path.split(os.path.split(self.__pathRAW)[0])[0])[0])[1]
        self.session=os.path.split(os.path.split(os.path.split(os.path.split(os.path.split(os.path.split(self.__pathRAW)[0])[0])[0])[0])[0])[1]
        self.subject=os.path.split(os.path.split(os.path.split(os.path.split(os.path.split(os.path.split(os.path.split(self.__pathRAW)[0])[0])[0])[0])[0])[0])[1]
        self.protocol=os.path.split(os.path.split(os.path.split(os.path.split(os.path.split(os.path.split(os.path.split(os.path.split(self.__pathRAW)[0])[0])[0])[0])[0])[0])[0])[1]
        self.database=os.path.split(os.path.split(os.path.split(os.path.split(os.path.split(os.path.split(os.path.split(os.path.split(self.__pathRAW)[0])[0])[0])[0])[0])[0])[0])[0]

    def __set_path_analysis( self ):
        """Initialization of __pathAnalysis using __pathRAW attribute
        """
        self.__pathAnalysis = os.path.join(os.path.split(os.path.split( self.__pathRAW )[0])[0],self.analysis)

    def __set_raw(self, RAW_path):
        """Initialization of __pathRAW attribute using the raw NIFTI image path

        Parameters
        ----------
        RAW_path : str
            The path of raw image

        Raises
        ------
        ValueError
            If extension of files are differents of '.nii', '.nii.gz'
        """
        if os.path.splitext(RAW_path)[1] != '.nii' and os.path.splitext(os.path.splitext(RAW_path)[0])[1]+os.path.splitext(RAW_path)[1] != '.nii.gz': # If file extension if not nii or nii.gz
            raise ValueError('File extension not supported for %s: extension should be .nii or .nii.gz' % RAW_path) # Raises an exception
        else:
            self.__pathRAW=RAW_path # RAW_path recuperation

    def __frame0_construction( self,image,window ):
        """Does the mean of the time serie's datas included in a time window

        Parameters
        ----------
        image : numpy array
            The input image
        window : list
            The datas of a time serie used to divide the global time serie (time1,time2)
        """
        frame0 = np.mean(image[window[0]:window[1],:],axis=0) # frame0 averaging
        return frame0

    def __linear_equation( self,image,window0,window1 ):
        """Construction of affine equation parameters

        Construction of a line which goes from the mean point of window0 to the mean point of window1

        Parameters
        ----------
        image : numpy array
            The input image
        window0 : list
            The datas at the beginning of a time serie used to divide the global time serie (time1,time2)
        window1 : list
            The datas at the end of a time serie used to divide the global time serie (time1,time2)
        Returns
        -------
        a : float
            The slope
        b : float
            The y-intercept
        """
        x0=(window0[0]+window0[1])/2 # The averaging of x in window0
        y0=self.__frame0_construction(image,window0) # The averaging of y in window0
        x1=(window1[0]+window1[1])/2 # The averaging of x in window1
        y1=self.__frame0_construction(image,window1) # The averaging of y in window1

        a=(y1-y0)/(x1-x0) # Estimation of slope
        b=(x1*y0-x0*y1)/(x1-x0) # Estimation of y-intercept

        return (a,b)

    def __setformat(self,format):
        """Set the NIFTI format (NIFTI-1 Image or gzip compressed NIFTI-1 Image)

        Parameters
        ----------
        format : {'.nii','.nii.gz'}
            Saving format of images. It can be NIFTI-1 Image ('.nii') or gzip compressed NIFTI-1 Image ('.nii.gz')

        Raises
        ------
        ValueError
            If extension of files are differents of '.nii', '.nii.gz'
        """
        if format=='.nii' or format =='.nii.gz': # If format is NIFTI-1 or gzip compressed NIFTI-1
            self.format=format # Sets format
        else:
            raise ValueError("File extension not supported.") # Raises an exception

    def __set_blk(self, blkfile_path):
        """Initialization of __blkfile_path using BLK data file's path

        Parameters
        ----------
        blkfile_path : str
            The path of BLK data file
        """
        if os.path.splitext(blkfile_path)[1].upper() == '.BLK': # If file extension is BLK
            self.__blkfile_path=blkfile_path # Path recuperation
        else:
            raise ValueError('File extension not supported for %s: should be .BLK' % blkfile_path) # Raises an exception

    def __set_external(self, external_file_path):
        """Initialization of __external_file_path using BLK or RSD data file's path

        Parameters
        ----------
        external_file_path : str
            The path of BLK or RSD data file
        """
        extension = external_file_path[-3:].upper() # File extension recuperation
        if extension == 'BLK' or extension == 'RSD': # If file extention is BLK or RSD
            self.__external_file_path = external_file_path # Path recuperation
        else:
            raise ValueError('File extension not supported for %s: should be .BLK or .RSD' % external_file_path) # Raises an exception

    def __set_path_raw( self ):
        """
        ST: I think it's obsolete! Definetely if using Brainvisa's GUI! To be double checked if using scripts...
        Setting __pathRAW attribute using path and directories attributes
        """
        if self.format != '.nii' and self.format != '.nii.gz': # If format is not NIFTI-1 or gzip compressed NIFTI-1
            raise ValueError('File extension not supported') # Raises an exception

        filename=os.path.splitext(os.path.basename(self.__blkfile_path))[0] # Filename recuperation
        #### ST modified 4 linesbelow!
        self.session = filename[8:10] + filename[6:8] + filename[4:6]
        self.exp = filename[18:20]
        self.trial = filename[21:24]
        self.filename = 's' + self.session + '_e' + self.exp + '_t' + self.trial + '_c' + filename[2:4]

        self.__pathRAW=os.path.join(self.database,self.protocol,self.subject,'session_' + self.session,'oitrials_analysis','exp' + self.exp,'trial' + self.trial,'raw',self.filename + self.format ) # __pathRAW creation

    def __save_nifti( self,path,image,header ):
        """Save of NIFTI-1 image

        Parameters
        ----------
        path : str
            The saving path of the image
        image : numpy array
            The image to save
        header : dict
            The NIFTI header
        """
        if os.path.lexists(os.path.split(path)[0]) == False and os.path.split(path)[0] != '': # If path does not exist
            os.makedirs(os.path.split(path)[0]) # Directory creation

        image=np.array( np.transpose(image),order='F',dtype=np.float32 ) # Adaptation of array-type for a use in pyNIFTI
        Vol = aims.Volume_FLOAT( image ) # Volume creation
        # Setting headers
        Vol.header()[ 'xyz_units' ] = header[ 'xyz_units' ]
        Vol.header()[ 'time_units' ] = header[ 'time_units' ]
        Vol.header()[ 'voxel_size' ] = header[ 'voxel_size' ]
        aims.write( Vol, path.encode("utf8") ) # Saving data
